(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
const initGame = require('./resources/engine.js').initGame,
    player = require('./players/player.js'),
    allEnemies = require('./players/enemy.js').allEnemies,
    utils = require('./utils/utils.js'),
    gameProcess = require('./players/gameProcess.js');



var startPlayButton = document.querySelectorAll('.modalStart__button')[0],
    choosePlayerEl = document.querySelectorAll('#modalPlayers')[0],
    restartButton = document.querySelectorAll('.modalGameEnd__restartButton')[0];




// This listner for choosing player body. It sets choosen image 
// for player and set player property playerActive to true.
choosePlayerEl.addEventListener('click', function(e) {
    if (!player.playerBody) {
        utils.toggleClass(e.target, 'active');
    } else {
        utils.toggleClass(player.playerBody, 'active');
        utils.toggleClass(e.target, 'active');
    }
    gameProcess.choosePlayer(e, player);
    player.activePlayer();
});




// On click hide modal start, set gameInProcess to `true`
// Initialize the game and delete CSS class active from modal window with players
startPlayButton.addEventListener('click', function(e) {
    if (player.getPlayerActivity()) {
        gameProcess.modalStartVisibility();
        gameProcess.setGameInProcess(true);
        gameProcess.gameInfoVisibility();
        initGame();
        utils.toggleClass(document.querySelectorAll('#modalPlayers .active')[0], 'active');
    }
});


// Restart button reset all properties for enemies and player to default.
// Close the ModalEnd and open start modal window
restartButton.addEventListener('click', function(e) {
    player.resetAllValues();
    allEnemies.forEach(function(enemy) {
        enemy.resetAllValues(-100);
    });

    gameProcess.gameEndModal();
    gameProcess.modalStartVisibility();
});

// This listens for key presses and sends the keys to your
// Player.handleInput() method. You don't need to modify this.
document.addEventListener('keyup', function(e) {
    var allowedKeys = {
        37: 'left',
        38: 'up',
        39: 'right',
        40: 'down'
    };

    player.handleInput(allowedKeys[e.keyCode]);
});
},{"./players/enemy.js":2,"./players/gameProcess.js":3,"./players/player.js":4,"./resources/engine.js":5,"./utils/utils.js":7}],2:[function(require,module,exports){
const Resources = require('../resources/resources.js'),
    utils = require('../utils/utils.js');

// Enemies our player must avoid
var Enemy = function(x, y) {
    // Variables applied to each of our instances go here,
    // we've provided one for you to get started

    // The image/sprite for our enemies, this uses
    // a helper we've provided to easily load images
    this.sprite = 'images/enemy-bug.png';
    this.x = x;
    this.y = y;
    this.speed = undefined;
    this.level = 1;
};



// Update the enemy's position, required method for game
// Parameter: dt, a time delta between ticks
Enemy.prototype.update = function(dt) {
    // You should multiply any movement by the dt parameter
    // which will ensure the game runs at the same speed for
    // all computers.
    if (!this.speed) {
        this.setSpeed();
    }
    
    this.x = this.x + (dt * this.speed);

    if (this.x > 101 * 6) {
        this.x = -100;
        this.setSpeed();
    }
};



// Draw the enemy on the screen, required method for game
Enemy.prototype.render = function(dt) {
    ctx.drawImage(Resources.get(this.sprite), this.x, this.y);
};


//Return current enemy position
Enemy.prototype.getPosition = function() {
    return {
        x: this.x,
        y: this.y
    };
};



// Increment difficulty level
Enemy.prototype.incrementLevel = function () {
    this.level += 1;
};



// Increment difficulty level
Enemy.prototype.decrementLevel = function () {
    this.level -= 1;
};



// Get difficulty level
Enemy.prototype.getLevel = function(){
    return this.level;
};

// Reset all values
// @param {Number} x Horizontal start position for all enemies
Enemy.prototype.resetAllValues = function(x){
    this.x = x;
    this.speed = undefined;
    this.level = 1;
};

// Set speed depends on difficulty level
Enemy.prototype.setSpeed = function() {
    let random = Math.random().toFixed(1) * 10;
    if(this.level === 1){
        random = random >= 5 ? random / 2 : random;
    } else if(this.level === 2){
        random = random >= 5 ? random : random * 2;
    } else if (this.level === 3){
        random = random >= 5 ? random * 3 : random * 4;
    } else {
        random = random >= 5 ? random * 5 : random * 6;
    }
    this.speed = Math.round(random * 50);
};


// Defined enemies
var enemy1 = new Enemy(-100, 53);
var enemy2 = new Enemy(-100, 136);
var enemy3 = new Enemy(-100, 219);


var allEnemies = [enemy1, enemy2, enemy3];


module.exports = {
    allEnemies: allEnemies
};
},{"../resources/resources.js":6,"../utils/utils.js":7}],3:[function(require,module,exports){
const Resources = require('../resources/resources.js'),
    utils = require('../utils/utils.js');

var allPlayers = [
        // Player sources
        'images/char-boy.png',
        'images/char-cat-girl.png',
        'images/char-horn-girl.png',
        'images/char-pink-girl.png',
        'images/char-princess-girl.png'
    ],
    allKeysForPlayers = [
        'Boy',
        'Cat',
        'Horn',
        'Pink',
        'Princess'
    ];

// GameProcess class manage some of game process like show and hide modal windows,
// game status to stop and reset the game and other

function GameProcess() {
    this.gemGreen = 'images/Gem_Green.png';
    this.gemBlue = 'images/Gem_Blue.png';
    this.gemOrange = 'images/Gem_Orange.png';

    this.gameInProcess = false;
}


// Check, if this property exist in GameProcess class
GameProcess.prototype.getProperty = function(propertyName) {
    if (this && this[propertyName]) {
        return this[propertyName];
    } else {
        console.warn(`Sorry ${propertyName} or "this" object doesn't exist.`);
    }
};


// Set the game to given process status
// @param {Boolean} inProcess If `false` the game will be stoped
GameProcess.prototype.setGameInProcess = function(inProcess) {
    this.gameInProcess = inProcess;
};

// Return status of game process
GameProcess.prototype.getGameInProcess = function() {
    return this.gameInProcess;
};

// Hide the game end modal window if it visible, and show if not visible
GameProcess.prototype.gameEndModal = function(result) {
    gameEndWindow = document.querySelectorAll('.modalGameEnd')[0];

    if (gameEndWindow.className.indexOf('active') > -1) {
        document.querySelectorAll('.modalGameEnd .resultText')[0].textContent = '';
        utils.toggleClass(gameEndWindow, 'active');
    } else {
        document.querySelectorAll('.modalGameEnd .resultText')[0].textContent = result;
        utils.toggleClass(gameEndWindow, 'active');
    }
};

// Hide the game Info window if it visible, and show if not visible
GameProcess.prototype.gameInfoVisibility = function() {
    let gameInfoEl = document.querySelectorAll('#gameInfo')[0];

    utils.toggleClass(gameInfoEl, 'active');
};

// Hide the game start window if it visible, and show if not visible
GameProcess.prototype.modalStartVisibility = function() {
    let modalWindow = document.querySelectorAll('.modalStart')[0];

    utils.toggleClass(modalWindow, 'active');
};

// Choose player on click call {#Player.setPlayer} method
GameProcess.prototype.choosePlayer = function(e, playerCmp) {
    var playerData = e.target.dataset,
        i, len;

    for (i = 0, len = allPlayers.length; i < len; i++) {
        if (allPlayers[i].indexOf(playerData.bodyType.toLowerCase()) > -1) {
            playerCmp.setPlayer(Resources.get(allPlayers[i]));
        }
    }
};

// Clear the game board
GameProcess.prototype.clearGameBoard = function(canvas) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
};


// Create and add all availible player images to the start modal window
GameProcess.prototype.addPlayersToModalStart = function() {
    var modalPlayers = document.getElementById('modalPlayers'),
        playerContainer, playerContainerText, player, i, j, len, lenJ;

    for (i = 0, len = allPlayers.length; i < len; i++) {
        player = Resources.get(allPlayers[i]);
        playerContainer = utils.createEl('div');
        playerContainerText = utils.createEl('span');
        playerContainer.className = 'playerContainer';

        for (j = 0, lenJ = allKeysForPlayers.length; j < lenJ; j++) {
            if (allPlayers[i].indexOf(allKeysForPlayers[j].toLowerCase()) > -1) {
                player.dataset.bodyType = allKeysForPlayers[j];
                playerContainerText.textContent = allKeysForPlayers[j];
                playerContainer.appendChild(player);
                playerContainer.appendChild(playerContainerText);
            }
        }
        modalPlayers.appendChild(playerContainer);
    }
};

// Update current game information like score, player lives and speed level
GameProcess.prototype.update = function(player, enemy) {
    document.querySelectorAll('#gameInfo .scoreFieldValue')[0].textContent = player.getScore();
    document.querySelectorAll('#gameInfo .livesFieldValue')[0].textContent = player.getLives();
    document.querySelectorAll('#gameInfo .enemySpeedValue')[0].textContent = enemy.getLevel();
};

let gameProcess = new GameProcess();

module.exports = gameProcess;
},{"../resources/resources.js":6,"../utils/utils.js":7}],4:[function(require,module,exports){
const Resources = require('../resources/resources.js'),
    utils = require('../utils/utils.js'),
    gameProcess = require('./gameProcess.js');

// Now write your own player class
// This class requires an update(), render() and
// a handleInput() method.
var Player = function() {
    this.playerBody = undefined;
    this.playerIsActive = false;
    this.lives = 5;
    this.score = 0;
    this.maxScore = 15;
};


// Add to Playerbody(image) and set coordinates for player start
Player.prototype.setPlayer = function(player) {
    this.playerBody = player;
    this.x = 101 * 2;
    this.y = 83 * 5 - 32;
};

// Reduce player live and return player to start
Player.prototype.fail = function() {
    this.lives -= 1;
    if (this.lives > 0) {
        this.returnToStart();
    }
};

// Add points to score and return player to start
Player.prototype.win = function() {
    if(this.score < this.maxScore){
        this.returnToStart();
    }
};

// return player to start
Player.prototype.returnToStart = function() {
        this.x = 101 * 2;
        this.y = 83 * 5 - 32;
};

// Add one point to score
Player.prototype.incrementScore = function() {
    this.score += 1;
};

// Set player active
// This property blocks the start button till player body(image) will be set
Player.prototype.activePlayer = function() {
    this.playerIsActive = true;
};

// Return true if player body exist and 
Player.prototype.getPlayerActivity = function() {
    return this.playerIsActive;
};


// Return player's lives
Player.prototype.getLives = function() {
    return this.lives;
};

// Return player's score
Player.prototype.getScore = function() {
    return this.score;
};

// Return current player position
Player.prototype.getPosition = function() {
    return {
        x: this.x,
        y: this.y
    };
};

// Set default values for all properties in class
Player.prototype.resetAllValues = function() {
   this.playerBody = undefined;
    this.playerIsActive = false;
    this.lives = 5;
    this.score = 0;
    this.maxScore = 15;
};


// Manage player moves
Player.prototype.handleInput = function(code) {
    switch (code) {
        case 'up': // if (x === 'value1')
            if (this.y > -84 && (this.y - 83) > -84) {
                this.y = this.y - 83;
            }
            break;
        case 'down':
            if (this.y < 83 * 5 && (this.y + 83) < 83 * 5) {
                this.y = this.y + 83;
            }
            break;
        case 'right':
            if (this.x > -1 && (this.x + 101) < 101 * 5) {
                this.x = this.x + 101;
            }
            break;
        case 'left':
            if (this.x < 101 * 5 && (this.x - 101) > -1) {
                this.x = this.x - 101;
            }
            break;
    }

};

// Update player info and if player is on the finish water line, add to score 1 point
// return the player on start and increase the speed of enemies
Player.prototype.update = function(enemies) {
    if (this.y < 0) {
        this.returnToStart();
        this.incrementScore();
        enemies.forEach(function(enemy) {
            enemy.incrementLevel();
        });
    }
};

// Draw the player on the screen, required method for game
Player.prototype.render = function(code) {
    ctx.drawImage(this.playerBody, this.x, this.y);
};

var player = new Player();


module.exports = player;
},{"../resources/resources.js":6,"../utils/utils.js":7,"./gameProcess.js":3}],5:[function(require,module,exports){
/* Engine.js
 * This file provides the game loop functionality (update entities and render),
 * draws the initial game board on the screen, and then calls the update and
 * render methods on your player and enemy objects (defined in your app.js).
 *
 * A game engine works by drawing the entire game screen over and over, kind of
 * like a flipbook you may have created as a kid. When your player moves across
 * the screen, it may look like just that image/character is moving or being
 * drawn but that is not the case. What's really happening is the entire "scene"
 * is being drawn over and over, presenting the illusion of animation.
 *
 * This engine makes the canvas' context (ctx) object globally available to make
 * writing app.js a little simpler to work with.
 */


const Resources = require('./resources.js'),
    enemyCmp = require('../players/enemy.js'),
    playerCmp = require('../players/player.js'),
    gameProcess = require('../players/gameProcess.js'),
    utils = require('../utils/utils.js');

/* Predefine the variables we'll be using within this scope,
 * create the canvas element, grab the 2D context for that canvas
 * set the canvas element's height/width and add it to the DOM.
 */

var doc = window.document,
    win = window.window,
    canvas = utils.createEl('canvas'),
    ctx = canvas.getContext('2d'),
    mainGameContainer = document.getElementById('mainGameContainer'),
    gameInfoEl = document.getElementById('gameInfo'),
    lastTime, allEnemies;

canvas.width = 505;
canvas.height = 606;
mainGameContainer.insertBefore(canvas, gameInfoEl);

/* This function serves as the kickoff point for the game loop itself
 * and handles properly calling the update and render methods.
 */
function main() {
    /* Get our time delta information which is required if your game
     * requires smooth animation. Because everyone's computer processes
     * instructions at different speeds we need a constant value that
     * would be the same for everyone (regardless of how fast their
     * computer is) - hurray time!
     */
    var now = Date.now(),
        dt = (now - lastTime) / 1000.0;

    /* Call our update/render functions, pass along the time delta to
     * our update function since it may be used for smooth animation.
     */
    update(dt);
    render();

    /* Set our lastTime variable which is used to determine the time delta
     * for the next time this function is called.
     */
    lastTime = now;

    /* Use the browser's requestAnimationFrame function to call this
     * function again as soon as the browser is able to draw another frame.
     */
    if (gameProcess.getGameInProcess()) {
        win.requestAnimationFrame(main);
    }
}

/* This function does some initial setup that should only occur once,
 * particularly setting the lastTime variable that is required for the
 * game loop.
 */
function init() {
    lastTime = Date.now();
    main();
}

/* This function is called by main (our game loop) and itself calls all
 * of the functions which may need to update entity's data. Based on how
 * you implement your collision detection (when two entities occupy the
 * same space, for instance when your character should die), you may find
 * the need to add an additional function call here. For now, we've left
 * it commented out - you may or may not want to implement this
 * functionality this way (you could just implement collision detection
 * on the entities themselves within your app.js file).
 */
function update(dt) {
    enemyCmp.allEnemies.forEach(function(enemy) {
        comparePositions(enemy, playerCmp);
    });
    updateEntities(dt);
}

/* This is called by the update function and loops through all of the
 * objects within your allEnemies array as defined in app.js and calls
 * their update() methods. It will then call the update function for your
 * player object. These update methods should focus purely on updating
 * the data/properties related to the object. Do your drawing in your
 * render methods.
 */
function updateEntities(dt) {
    enemyCmp.allEnemies.forEach(function(enemy) {
        enemy.update(dt);
    });

    playerCmp.update(enemyCmp.allEnemies);

    if (playerCmp.getScore() >= 15) {
        reset('You win!');
    } else if (playerCmp.getLives() <= 0) {
        reset('Sorry, you lose!');
    }
}

/* This function initially draws the "game level", it will then call
 * the renderEntities function. Remember, this function is called every
 * game tick (or loop of the game engine) because that's how games work -
 * they are flipbooks creating the illusion of animation but in reality
 * they are just drawing the entire screen over and over.
 */
function render() {
    /* This array holds the relative URL to the image used
     * for that particular row of the game level.
     */
    var rowImages = [
            'images/water-block.png', // Top row is water
            'images/stone-block.png', // Row 1 of 3 of stone
            'images/stone-block.png', // Row 2 of 3 of stone
            'images/stone-block.png', // Row 3 of 3 of stone
            'images/grass-block.png', // Row 1 of 2 of grass
            'images/grass-block.png' // Row 2 of 2 of grass
        ],
        numRows = 6,
        numCols = 5,
        row, col;

    // Before drawing, clear existing canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    /* Loop through the number of rows and columns we've defined above
     * and, using the rowImages array, draw the correct image for that
     * portion of the "grid"
     */
    for (row = 0; row < numRows; row++) {
        for (col = 0; col < numCols; col++) {
            /* The drawImage function of the canvas' context element
             * requires 3 parameters: the image to draw, the x coordinate
             * to start drawing and the y coordinate to start drawing.
             * We're using our Resources helpers to refer to our images
             * so that we get the benefits of caching these images, since
             * we're using them over and over.
             */
            ctx.drawImage(Resources.get(rowImages[row]), col * 101, row * 83);
        }
    }

    renderEntities();
    gameProcess.update(playerCmp, enemyCmp.allEnemies[0]);
}

/* This function is called by the render function and is called on each game
 * tick. Its purpose is to then call the render functions you have defined
 * on your enemy and player entities within app.js
 */
function renderEntities() {
    /* Loop through all of the objects within the allEnemies array and call
     * the render function you have defined.
     */
    enemyCmp.allEnemies.forEach(function(enemy) {
        enemy.render();
    });

    playerCmp.render();
}


// Compare positions of enemies and player
// If player meet enemy than will be called player method {#Player.fail}
function comparePositions(enemy, player) {
    let playerPos = player.getPosition(),
        enemyPos = enemy.getPosition(),
        playerLeft, playerRight, playerTop,
        enemyLeft, enemyRight, enemyBottom,
        compareLevelHigh;

    playerLeft = player.x;
    playerRight = player.x + 101;
    playerTop = player.y + 70;

    enemyLeft = enemyPos.x + 40;
    enemyRight = enemyPos.x + 61;
    enemyBottom = enemyPos.y + 171;
    enemyTop = enemyPos.y + 70;

    compareLevelHigh = Math.ceil(playerTop / 10) === Math.ceil(enemyTop / 10);

    if (playerLeft < enemyRight && playerRight > enemyLeft && compareLevelHigh) {
        playerCmp.fail();
    }
}

/* This function does nothing but it could have been a good place to
 * handle game reset states - maybe a new game menu or a game over screen
 * those sorts of things. It's only called once by the init() method.
 */
function reset(result) {
    gameProcess.setGameInProcess(false);
    gameProcess.clearGameBoard(canvas);
    gameProcess.gameInfoVisibility();
    gameProcess.gameEndModal(result);
}

/* Go ahead and load all of the images we know we're going to need to
 * draw our game level. Then set init as the callback method, so that when
 * all of these images are properly loaded our game will start.
 */
Resources.load([
    // Map sources
    'images/stone-block.png',
    'images/water-block.png',
    'images/grass-block.png',
    // Enemy source
    'images/enemy-bug.png',
    // Bonuses sources
    'images/Gem_Blue.png',
    'images/Gem_Green.png',
    'images/Gem_Orange.png',
    // Player sources
    'images/char-boy.png',
    'images/char-cat-girl.png',
    'images/char-horn-girl.png',
    'images/char-pink-girl.png',
    'images/char-princess-girl.png'
]);
// Resources.onReady(init);
Resources.onReady(gameProcess.addPlayersToModalStart);

/* Assign the canvas' context object to the global variable (the window
 * object when run in a browser) so that developers can use it more easily
 * from within their app.js files.
 */
window.ctx = ctx;

module.exports = {
    initGame: init,
    resetGame: reset,
    main: main
};
},{"../players/enemy.js":2,"../players/gameProcess.js":3,"../players/player.js":4,"../utils/utils.js":7,"./resources.js":6}],6:[function(require,module,exports){
/* Resources.js
 * This is simply an image loading utility. It eases the process of loading
 * image files so that they can be used within your game. It also includes
 * a simple "caching" layer so it will reuse cached images if you attempt
 * to load the same image multiple times.
 */
var Resources = (function() {
    var resourceCache = {};
    var readyCallbacks = [];

    /* This is the publicly accessible image loading function. It accepts
     * an array of strings pointing to image files or a string for a single
     * image. It will then call our private image loading function accordingly.
     */
    function load(urlOrArr) {
        if(urlOrArr instanceof Array) {
            /* If the developer passed in an array of images
             * loop through each value and call our image
             * loader on that image file
             */
            urlOrArr.forEach(function(url) {
                _load(url);
            });
        } else {
            /* The developer did not pass an array to this function,
             * assume the value is a string and call our image loader
             * directly.
             */
            _load(urlOrArr);
        }
    }

    /* This is our private image loader function, it is
     * called by the public image loader function.
     */
    function _load(url) {
        if(resourceCache[url]) {
            /* If this URL has been previously loaded it will exist within
             * our resourceCache array. Just return that image rather than
             * re-loading the image.
             */
            return resourceCache[url];
        } else {
            /* This URL has not been previously loaded and is not present
             * within our cache; we'll need to load this image.
             */
            var img = new Image();
            img.onload = function() {
                /* Once our image has properly loaded, add it to our cache
                 * so that we can simply return this image if the developer
                 * attempts to load this file in the future.
                 */
                resourceCache[url] = img;

                /* Once the image is actually loaded and properly cached,
                 * call all of the onReady() callbacks we have defined.
                 */
                if(isReady()) {
                    readyCallbacks.forEach(function(func) { 
                        func.call(); 
                    });
                }
            };

            /* Set the initial cache value to false, this will change when
             * the image's onload event handler is called. Finally, point
             * the image's src attribute to the passed in URL.
             */
            resourceCache[url] = false;
            img.src = url;
        }
    }

    /* This is used by developers to grab references to images they know
     * have been previously loaded. If an image is cached, this functions
     * the same as calling load() on that URL.
     */
    function get(url) {
        return resourceCache[url];
    }

    /* This function determines if all of the images that have been requested
     * for loading have in fact been properly loaded.
     */
    function isReady() {
        var ready = true;
        for(var k in resourceCache) {
            if(resourceCache.hasOwnProperty(k) &&
               !resourceCache[k]) {
                ready = false;
            }
        }
        return ready;
    }

    /* This function will add a function to the callback stack that is called
     * when all requested images are properly loaded.
     */
    function onReady(func) {
        readyCallbacks.push(func);
    }

    /* This object defines the publicly accessible functions available to
     * developers by creating a global Resources object.
     */
    return {
        load: load,
        get: get,
        onReady: onReady,
        isReady: isReady
    };
})();

module.exports = Resources;

},{}],7:[function(require,module,exports){
/**
 * @description Toggle given class using cross browser property ClassName.
 * @param {Object} element DOMElement to toggle class.
 * @param {String} className Class name that should be toggled.
 */
// toggleClass function from https://stackoverflow.com/questions/18880890/how-do-i-toggle-an-elements-class-in-pure-javascript
function toggleClass(element, className) {
    if (!element || !className) {
        return;
    }

    var classString = element.className,
        nameIndex = classString.indexOf(className);
    if (nameIndex == -1) {
        classString += ' ' + className;
    } else {
        classString = classString.substr(0, nameIndex) + classString.substr(nameIndex + className.length);
    }
    element.className = classString;
}

// Shortcut for create element
function createEl(tag){
    return document.createElement(tag);
}

module.exports = {
    toggleClass: toggleClass,
    createEl: createEl
};
},{}]},{},[1,2,3,4,5,6,7])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvanMvZXZlbnRIYW5kbGVyLmpzIiwic3JjL2pzL3BsYXllcnMvZW5lbXkuanMiLCJzcmMvanMvcGxheWVycy9nYW1lUHJvY2Vzcy5qcyIsInNyYy9qcy9wbGF5ZXJzL3BsYXllci5qcyIsInNyYy9qcy9yZXNvdXJjZXMvZW5naW5lLmpzIiwic3JjL2pzL3Jlc291cmNlcy9yZXNvdXJjZXMuanMiLCJzcmMvanMvdXRpbHMvdXRpbHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsImNvbnN0IGluaXRHYW1lID0gcmVxdWlyZSgnLi9yZXNvdXJjZXMvZW5naW5lLmpzJykuaW5pdEdhbWUsXHJcbiAgICBwbGF5ZXIgPSByZXF1aXJlKCcuL3BsYXllcnMvcGxheWVyLmpzJyksXHJcbiAgICBhbGxFbmVtaWVzID0gcmVxdWlyZSgnLi9wbGF5ZXJzL2VuZW15LmpzJykuYWxsRW5lbWllcyxcclxuICAgIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscy91dGlscy5qcycpLFxyXG4gICAgZ2FtZVByb2Nlc3MgPSByZXF1aXJlKCcuL3BsYXllcnMvZ2FtZVByb2Nlc3MuanMnKTtcclxuXHJcblxyXG5cclxudmFyIHN0YXJ0UGxheUJ1dHRvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5tb2RhbFN0YXJ0X19idXR0b24nKVswXSxcclxuICAgIGNob29zZVBsYXllckVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI21vZGFsUGxheWVycycpWzBdLFxyXG4gICAgcmVzdGFydEJ1dHRvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5tb2RhbEdhbWVFbmRfX3Jlc3RhcnRCdXR0b24nKVswXTtcclxuXHJcblxyXG5cclxuXHJcbi8vIFRoaXMgbGlzdG5lciBmb3IgY2hvb3NpbmcgcGxheWVyIGJvZHkuIEl0IHNldHMgY2hvb3NlbiBpbWFnZSBcclxuLy8gZm9yIHBsYXllciBhbmQgc2V0IHBsYXllciBwcm9wZXJ0eSBwbGF5ZXJBY3RpdmUgdG8gdHJ1ZS5cclxuY2hvb3NlUGxheWVyRWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAgICBpZiAoIXBsYXllci5wbGF5ZXJCb2R5KSB7XHJcbiAgICAgICAgdXRpbHMudG9nZ2xlQ2xhc3MoZS50YXJnZXQsICdhY3RpdmUnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdXRpbHMudG9nZ2xlQ2xhc3MocGxheWVyLnBsYXllckJvZHksICdhY3RpdmUnKTtcclxuICAgICAgICB1dGlscy50b2dnbGVDbGFzcyhlLnRhcmdldCwgJ2FjdGl2ZScpO1xyXG4gICAgfVxyXG4gICAgZ2FtZVByb2Nlc3MuY2hvb3NlUGxheWVyKGUsIHBsYXllcik7XHJcbiAgICBwbGF5ZXIuYWN0aXZlUGxheWVyKCk7XHJcbn0pO1xyXG5cclxuXHJcblxyXG5cclxuLy8gT24gY2xpY2sgaGlkZSBtb2RhbCBzdGFydCwgc2V0IGdhbWVJblByb2Nlc3MgdG8gYHRydWVgXHJcbi8vIEluaXRpYWxpemUgdGhlIGdhbWUgYW5kIGRlbGV0ZSBDU1MgY2xhc3MgYWN0aXZlIGZyb20gbW9kYWwgd2luZG93IHdpdGggcGxheWVyc1xyXG5zdGFydFBsYXlCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAgICBpZiAocGxheWVyLmdldFBsYXllckFjdGl2aXR5KCkpIHtcclxuICAgICAgICBnYW1lUHJvY2Vzcy5tb2RhbFN0YXJ0VmlzaWJpbGl0eSgpO1xyXG4gICAgICAgIGdhbWVQcm9jZXNzLnNldEdhbWVJblByb2Nlc3ModHJ1ZSk7XHJcbiAgICAgICAgZ2FtZVByb2Nlc3MuZ2FtZUluZm9WaXNpYmlsaXR5KCk7XHJcbiAgICAgICAgaW5pdEdhbWUoKTtcclxuICAgICAgICB1dGlscy50b2dnbGVDbGFzcyhkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjbW9kYWxQbGF5ZXJzIC5hY3RpdmUnKVswXSwgJ2FjdGl2ZScpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcblxyXG4vLyBSZXN0YXJ0IGJ1dHRvbiByZXNldCBhbGwgcHJvcGVydGllcyBmb3IgZW5lbWllcyBhbmQgcGxheWVyIHRvIGRlZmF1bHQuXHJcbi8vIENsb3NlIHRoZSBNb2RhbEVuZCBhbmQgb3BlbiBzdGFydCBtb2RhbCB3aW5kb3dcclxucmVzdGFydEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcclxuICAgIHBsYXllci5yZXNldEFsbFZhbHVlcygpO1xyXG4gICAgYWxsRW5lbWllcy5mb3JFYWNoKGZ1bmN0aW9uKGVuZW15KSB7XHJcbiAgICAgICAgZW5lbXkucmVzZXRBbGxWYWx1ZXMoLTEwMCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBnYW1lUHJvY2Vzcy5nYW1lRW5kTW9kYWwoKTtcclxuICAgIGdhbWVQcm9jZXNzLm1vZGFsU3RhcnRWaXNpYmlsaXR5KCk7XHJcbn0pO1xyXG5cclxuLy8gVGhpcyBsaXN0ZW5zIGZvciBrZXkgcHJlc3NlcyBhbmQgc2VuZHMgdGhlIGtleXMgdG8geW91clxyXG4vLyBQbGF5ZXIuaGFuZGxlSW5wdXQoKSBtZXRob2QuIFlvdSBkb24ndCBuZWVkIHRvIG1vZGlmeSB0aGlzLlxyXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGZ1bmN0aW9uKGUpIHtcclxuICAgIHZhciBhbGxvd2VkS2V5cyA9IHtcclxuICAgICAgICAzNzogJ2xlZnQnLFxyXG4gICAgICAgIDM4OiAndXAnLFxyXG4gICAgICAgIDM5OiAncmlnaHQnLFxyXG4gICAgICAgIDQwOiAnZG93bidcclxuICAgIH07XHJcblxyXG4gICAgcGxheWVyLmhhbmRsZUlucHV0KGFsbG93ZWRLZXlzW2Uua2V5Q29kZV0pO1xyXG59KTsiLCJjb25zdCBSZXNvdXJjZXMgPSByZXF1aXJlKCcuLi9yZXNvdXJjZXMvcmVzb3VyY2VzLmpzJyksXHJcbiAgICB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3V0aWxzLmpzJyk7XHJcblxyXG4vLyBFbmVtaWVzIG91ciBwbGF5ZXIgbXVzdCBhdm9pZFxyXG52YXIgRW5lbXkgPSBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICAvLyBWYXJpYWJsZXMgYXBwbGllZCB0byBlYWNoIG9mIG91ciBpbnN0YW5jZXMgZ28gaGVyZSxcclxuICAgIC8vIHdlJ3ZlIHByb3ZpZGVkIG9uZSBmb3IgeW91IHRvIGdldCBzdGFydGVkXHJcblxyXG4gICAgLy8gVGhlIGltYWdlL3Nwcml0ZSBmb3Igb3VyIGVuZW1pZXMsIHRoaXMgdXNlc1xyXG4gICAgLy8gYSBoZWxwZXIgd2UndmUgcHJvdmlkZWQgdG8gZWFzaWx5IGxvYWQgaW1hZ2VzXHJcbiAgICB0aGlzLnNwcml0ZSA9ICdpbWFnZXMvZW5lbXktYnVnLnBuZyc7XHJcbiAgICB0aGlzLnggPSB4O1xyXG4gICAgdGhpcy55ID0geTtcclxuICAgIHRoaXMuc3BlZWQgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmxldmVsID0gMTtcclxufTtcclxuXHJcblxyXG5cclxuLy8gVXBkYXRlIHRoZSBlbmVteSdzIHBvc2l0aW9uLCByZXF1aXJlZCBtZXRob2QgZm9yIGdhbWVcclxuLy8gUGFyYW1ldGVyOiBkdCwgYSB0aW1lIGRlbHRhIGJldHdlZW4gdGlja3NcclxuRW5lbXkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGR0KSB7XHJcbiAgICAvLyBZb3Ugc2hvdWxkIG11bHRpcGx5IGFueSBtb3ZlbWVudCBieSB0aGUgZHQgcGFyYW1ldGVyXHJcbiAgICAvLyB3aGljaCB3aWxsIGVuc3VyZSB0aGUgZ2FtZSBydW5zIGF0IHRoZSBzYW1lIHNwZWVkIGZvclxyXG4gICAgLy8gYWxsIGNvbXB1dGVycy5cclxuICAgIGlmICghdGhpcy5zcGVlZCkge1xyXG4gICAgICAgIHRoaXMuc2V0U3BlZWQoKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdGhpcy54ID0gdGhpcy54ICsgKGR0ICogdGhpcy5zcGVlZCk7XHJcblxyXG4gICAgaWYgKHRoaXMueCA+IDEwMSAqIDYpIHtcclxuICAgICAgICB0aGlzLnggPSAtMTAwO1xyXG4gICAgICAgIHRoaXMuc2V0U3BlZWQoKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuLy8gRHJhdyB0aGUgZW5lbXkgb24gdGhlIHNjcmVlbiwgcmVxdWlyZWQgbWV0aG9kIGZvciBnYW1lXHJcbkVuZW15LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihkdCkge1xyXG4gICAgY3R4LmRyYXdJbWFnZShSZXNvdXJjZXMuZ2V0KHRoaXMuc3ByaXRlKSwgdGhpcy54LCB0aGlzLnkpO1xyXG59O1xyXG5cclxuXHJcbi8vUmV0dXJuIGN1cnJlbnQgZW5lbXkgcG9zaXRpb25cclxuRW5lbXkucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IHRoaXMueCxcclxuICAgICAgICB5OiB0aGlzLnlcclxuICAgIH07XHJcbn07XHJcblxyXG5cclxuXHJcbi8vIEluY3JlbWVudCBkaWZmaWN1bHR5IGxldmVsXHJcbkVuZW15LnByb3RvdHlwZS5pbmNyZW1lbnRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMubGV2ZWwgKz0gMTtcclxufTtcclxuXHJcblxyXG5cclxuLy8gSW5jcmVtZW50IGRpZmZpY3VsdHkgbGV2ZWxcclxuRW5lbXkucHJvdG90eXBlLmRlY3JlbWVudExldmVsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5sZXZlbCAtPSAxO1xyXG59O1xyXG5cclxuXHJcblxyXG4vLyBHZXQgZGlmZmljdWx0eSBsZXZlbFxyXG5FbmVteS5wcm90b3R5cGUuZ2V0TGV2ZWwgPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIHRoaXMubGV2ZWw7XHJcbn07XHJcblxyXG4vLyBSZXNldCBhbGwgdmFsdWVzXHJcbi8vIEBwYXJhbSB7TnVtYmVyfSB4IEhvcml6b250YWwgc3RhcnQgcG9zaXRpb24gZm9yIGFsbCBlbmVtaWVzXHJcbkVuZW15LnByb3RvdHlwZS5yZXNldEFsbFZhbHVlcyA9IGZ1bmN0aW9uKHgpe1xyXG4gICAgdGhpcy54ID0geDtcclxuICAgIHRoaXMuc3BlZWQgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmxldmVsID0gMTtcclxufTtcclxuXHJcbi8vIFNldCBzcGVlZCBkZXBlbmRzIG9uIGRpZmZpY3VsdHkgbGV2ZWxcclxuRW5lbXkucHJvdG90eXBlLnNldFNwZWVkID0gZnVuY3Rpb24oKSB7XHJcbiAgICBsZXQgcmFuZG9tID0gTWF0aC5yYW5kb20oKS50b0ZpeGVkKDEpICogMTA7XHJcbiAgICBpZih0aGlzLmxldmVsID09PSAxKXtcclxuICAgICAgICByYW5kb20gPSByYW5kb20gPj0gNSA/IHJhbmRvbSAvIDIgOiByYW5kb207XHJcbiAgICB9IGVsc2UgaWYodGhpcy5sZXZlbCA9PT0gMil7XHJcbiAgICAgICAgcmFuZG9tID0gcmFuZG9tID49IDUgPyByYW5kb20gOiByYW5kb20gKiAyO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLmxldmVsID09PSAzKXtcclxuICAgICAgICByYW5kb20gPSByYW5kb20gPj0gNSA/IHJhbmRvbSAqIDMgOiByYW5kb20gKiA0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByYW5kb20gPSByYW5kb20gPj0gNSA/IHJhbmRvbSAqIDUgOiByYW5kb20gKiA2O1xyXG4gICAgfVxyXG4gICAgdGhpcy5zcGVlZCA9IE1hdGgucm91bmQocmFuZG9tICogNTApO1xyXG59O1xyXG5cclxuXHJcbi8vIERlZmluZWQgZW5lbWllc1xyXG52YXIgZW5lbXkxID0gbmV3IEVuZW15KC0xMDAsIDUzKTtcclxudmFyIGVuZW15MiA9IG5ldyBFbmVteSgtMTAwLCAxMzYpO1xyXG52YXIgZW5lbXkzID0gbmV3IEVuZW15KC0xMDAsIDIxOSk7XHJcblxyXG5cclxudmFyIGFsbEVuZW1pZXMgPSBbZW5lbXkxLCBlbmVteTIsIGVuZW15M107XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBhbGxFbmVtaWVzOiBhbGxFbmVtaWVzXHJcbn07IiwiY29uc3QgUmVzb3VyY2VzID0gcmVxdWlyZSgnLi4vcmVzb3VyY2VzL3Jlc291cmNlcy5qcycpLFxyXG4gICAgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy91dGlscy5qcycpO1xyXG5cclxudmFyIGFsbFBsYXllcnMgPSBbXHJcbiAgICAgICAgLy8gUGxheWVyIHNvdXJjZXNcclxuICAgICAgICAnaW1hZ2VzL2NoYXItYm95LnBuZycsXHJcbiAgICAgICAgJ2ltYWdlcy9jaGFyLWNhdC1naXJsLnBuZycsXHJcbiAgICAgICAgJ2ltYWdlcy9jaGFyLWhvcm4tZ2lybC5wbmcnLFxyXG4gICAgICAgICdpbWFnZXMvY2hhci1waW5rLWdpcmwucG5nJyxcclxuICAgICAgICAnaW1hZ2VzL2NoYXItcHJpbmNlc3MtZ2lybC5wbmcnXHJcbiAgICBdLFxyXG4gICAgYWxsS2V5c0ZvclBsYXllcnMgPSBbXHJcbiAgICAgICAgJ0JveScsXHJcbiAgICAgICAgJ0NhdCcsXHJcbiAgICAgICAgJ0hvcm4nLFxyXG4gICAgICAgICdQaW5rJyxcclxuICAgICAgICAnUHJpbmNlc3MnXHJcbiAgICBdO1xyXG5cclxuLy8gR2FtZVByb2Nlc3MgY2xhc3MgbWFuYWdlIHNvbWUgb2YgZ2FtZSBwcm9jZXNzIGxpa2Ugc2hvdyBhbmQgaGlkZSBtb2RhbCB3aW5kb3dzLFxyXG4vLyBnYW1lIHN0YXR1cyB0byBzdG9wIGFuZCByZXNldCB0aGUgZ2FtZSBhbmQgb3RoZXJcclxuXHJcbmZ1bmN0aW9uIEdhbWVQcm9jZXNzKCkge1xyXG4gICAgdGhpcy5nZW1HcmVlbiA9ICdpbWFnZXMvR2VtX0dyZWVuLnBuZyc7XHJcbiAgICB0aGlzLmdlbUJsdWUgPSAnaW1hZ2VzL0dlbV9CbHVlLnBuZyc7XHJcbiAgICB0aGlzLmdlbU9yYW5nZSA9ICdpbWFnZXMvR2VtX09yYW5nZS5wbmcnO1xyXG5cclxuICAgIHRoaXMuZ2FtZUluUHJvY2VzcyA9IGZhbHNlO1xyXG59XHJcblxyXG5cclxuLy8gQ2hlY2ssIGlmIHRoaXMgcHJvcGVydHkgZXhpc3QgaW4gR2FtZVByb2Nlc3MgY2xhc3NcclxuR2FtZVByb2Nlc3MucHJvdG90eXBlLmdldFByb3BlcnR5ID0gZnVuY3Rpb24ocHJvcGVydHlOYW1lKSB7XHJcbiAgICBpZiAodGhpcyAmJiB0aGlzW3Byb3BlcnR5TmFtZV0pIHtcclxuICAgICAgICByZXR1cm4gdGhpc1twcm9wZXJ0eU5hbWVdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oYFNvcnJ5ICR7cHJvcGVydHlOYW1lfSBvciBcInRoaXNcIiBvYmplY3QgZG9lc24ndCBleGlzdC5gKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG4vLyBTZXQgdGhlIGdhbWUgdG8gZ2l2ZW4gcHJvY2VzcyBzdGF0dXNcclxuLy8gQHBhcmFtIHtCb29sZWFufSBpblByb2Nlc3MgSWYgYGZhbHNlYCB0aGUgZ2FtZSB3aWxsIGJlIHN0b3BlZFxyXG5HYW1lUHJvY2Vzcy5wcm90b3R5cGUuc2V0R2FtZUluUHJvY2VzcyA9IGZ1bmN0aW9uKGluUHJvY2Vzcykge1xyXG4gICAgdGhpcy5nYW1lSW5Qcm9jZXNzID0gaW5Qcm9jZXNzO1xyXG59O1xyXG5cclxuLy8gUmV0dXJuIHN0YXR1cyBvZiBnYW1lIHByb2Nlc3NcclxuR2FtZVByb2Nlc3MucHJvdG90eXBlLmdldEdhbWVJblByb2Nlc3MgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdhbWVJblByb2Nlc3M7XHJcbn07XHJcblxyXG4vLyBIaWRlIHRoZSBnYW1lIGVuZCBtb2RhbCB3aW5kb3cgaWYgaXQgdmlzaWJsZSwgYW5kIHNob3cgaWYgbm90IHZpc2libGVcclxuR2FtZVByb2Nlc3MucHJvdG90eXBlLmdhbWVFbmRNb2RhbCA9IGZ1bmN0aW9uKHJlc3VsdCkge1xyXG4gICAgZ2FtZUVuZFdpbmRvdyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5tb2RhbEdhbWVFbmQnKVswXTtcclxuXHJcbiAgICBpZiAoZ2FtZUVuZFdpbmRvdy5jbGFzc05hbWUuaW5kZXhPZignYWN0aXZlJykgPiAtMSkge1xyXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5tb2RhbEdhbWVFbmQgLnJlc3VsdFRleHQnKVswXS50ZXh0Q29udGVudCA9ICcnO1xyXG4gICAgICAgIHV0aWxzLnRvZ2dsZUNsYXNzKGdhbWVFbmRXaW5kb3csICdhY3RpdmUnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLm1vZGFsR2FtZUVuZCAucmVzdWx0VGV4dCcpWzBdLnRleHRDb250ZW50ID0gcmVzdWx0O1xyXG4gICAgICAgIHV0aWxzLnRvZ2dsZUNsYXNzKGdhbWVFbmRXaW5kb3csICdhY3RpdmUnKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIEhpZGUgdGhlIGdhbWUgSW5mbyB3aW5kb3cgaWYgaXQgdmlzaWJsZSwgYW5kIHNob3cgaWYgbm90IHZpc2libGVcclxuR2FtZVByb2Nlc3MucHJvdG90eXBlLmdhbWVJbmZvVmlzaWJpbGl0eSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgbGV0IGdhbWVJbmZvRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjZ2FtZUluZm8nKVswXTtcclxuXHJcbiAgICB1dGlscy50b2dnbGVDbGFzcyhnYW1lSW5mb0VsLCAnYWN0aXZlJyk7XHJcbn07XHJcblxyXG4vLyBIaWRlIHRoZSBnYW1lIHN0YXJ0IHdpbmRvdyBpZiBpdCB2aXNpYmxlLCBhbmQgc2hvdyBpZiBub3QgdmlzaWJsZVxyXG5HYW1lUHJvY2Vzcy5wcm90b3R5cGUubW9kYWxTdGFydFZpc2liaWxpdHkgPSBmdW5jdGlvbigpIHtcclxuICAgIGxldCBtb2RhbFdpbmRvdyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5tb2RhbFN0YXJ0JylbMF07XHJcblxyXG4gICAgdXRpbHMudG9nZ2xlQ2xhc3MobW9kYWxXaW5kb3csICdhY3RpdmUnKTtcclxufTtcclxuXHJcbi8vIENob29zZSBwbGF5ZXIgb24gY2xpY2sgY2FsbCB7I1BsYXllci5zZXRQbGF5ZXJ9IG1ldGhvZFxyXG5HYW1lUHJvY2Vzcy5wcm90b3R5cGUuY2hvb3NlUGxheWVyID0gZnVuY3Rpb24oZSwgcGxheWVyQ21wKSB7XHJcbiAgICB2YXIgcGxheWVyRGF0YSA9IGUudGFyZ2V0LmRhdGFzZXQsXHJcbiAgICAgICAgaSwgbGVuO1xyXG5cclxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGFsbFBsYXllcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBpZiAoYWxsUGxheWVyc1tpXS5pbmRleE9mKHBsYXllckRhdGEuYm9keVR5cGUudG9Mb3dlckNhc2UoKSkgPiAtMSkge1xyXG4gICAgICAgICAgICBwbGF5ZXJDbXAuc2V0UGxheWVyKFJlc291cmNlcy5nZXQoYWxsUGxheWVyc1tpXSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8vIENsZWFyIHRoZSBnYW1lIGJvYXJkXHJcbkdhbWVQcm9jZXNzLnByb3RvdHlwZS5jbGVhckdhbWVCb2FyZCA9IGZ1bmN0aW9uKGNhbnZhcykge1xyXG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG59O1xyXG5cclxuXHJcbi8vIENyZWF0ZSBhbmQgYWRkIGFsbCBhdmFpbGlibGUgcGxheWVyIGltYWdlcyB0byB0aGUgc3RhcnQgbW9kYWwgd2luZG93XHJcbkdhbWVQcm9jZXNzLnByb3RvdHlwZS5hZGRQbGF5ZXJzVG9Nb2RhbFN0YXJ0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgbW9kYWxQbGF5ZXJzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vZGFsUGxheWVycycpLFxyXG4gICAgICAgIHBsYXllckNvbnRhaW5lciwgcGxheWVyQ29udGFpbmVyVGV4dCwgcGxheWVyLCBpLCBqLCBsZW4sIGxlbko7XHJcblxyXG4gICAgZm9yIChpID0gMCwgbGVuID0gYWxsUGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIHBsYXllciA9IFJlc291cmNlcy5nZXQoYWxsUGxheWVyc1tpXSk7XHJcbiAgICAgICAgcGxheWVyQ29udGFpbmVyID0gdXRpbHMuY3JlYXRlRWwoJ2RpdicpO1xyXG4gICAgICAgIHBsYXllckNvbnRhaW5lclRleHQgPSB1dGlscy5jcmVhdGVFbCgnc3BhbicpO1xyXG4gICAgICAgIHBsYXllckNvbnRhaW5lci5jbGFzc05hbWUgPSAncGxheWVyQ29udGFpbmVyJztcclxuXHJcbiAgICAgICAgZm9yIChqID0gMCwgbGVuSiA9IGFsbEtleXNGb3JQbGF5ZXJzLmxlbmd0aDsgaiA8IGxlbko7IGorKykge1xyXG4gICAgICAgICAgICBpZiAoYWxsUGxheWVyc1tpXS5pbmRleE9mKGFsbEtleXNGb3JQbGF5ZXJzW2pdLnRvTG93ZXJDYXNlKCkpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIHBsYXllci5kYXRhc2V0LmJvZHlUeXBlID0gYWxsS2V5c0ZvclBsYXllcnNbal07XHJcbiAgICAgICAgICAgICAgICBwbGF5ZXJDb250YWluZXJUZXh0LnRleHRDb250ZW50ID0gYWxsS2V5c0ZvclBsYXllcnNbal07XHJcbiAgICAgICAgICAgICAgICBwbGF5ZXJDb250YWluZXIuYXBwZW5kQ2hpbGQocGxheWVyKTtcclxuICAgICAgICAgICAgICAgIHBsYXllckNvbnRhaW5lci5hcHBlbmRDaGlsZChwbGF5ZXJDb250YWluZXJUZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBtb2RhbFBsYXllcnMuYXBwZW5kQ2hpbGQocGxheWVyQ29udGFpbmVyKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIFVwZGF0ZSBjdXJyZW50IGdhbWUgaW5mb3JtYXRpb24gbGlrZSBzY29yZSwgcGxheWVyIGxpdmVzIGFuZCBzcGVlZCBsZXZlbFxyXG5HYW1lUHJvY2Vzcy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24ocGxheWVyLCBlbmVteSkge1xyXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI2dhbWVJbmZvIC5zY29yZUZpZWxkVmFsdWUnKVswXS50ZXh0Q29udGVudCA9IHBsYXllci5nZXRTY29yZSgpO1xyXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI2dhbWVJbmZvIC5saXZlc0ZpZWxkVmFsdWUnKVswXS50ZXh0Q29udGVudCA9IHBsYXllci5nZXRMaXZlcygpO1xyXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI2dhbWVJbmZvIC5lbmVteVNwZWVkVmFsdWUnKVswXS50ZXh0Q29udGVudCA9IGVuZW15LmdldExldmVsKCk7XHJcbn07XHJcblxyXG5sZXQgZ2FtZVByb2Nlc3MgPSBuZXcgR2FtZVByb2Nlc3MoKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZ2FtZVByb2Nlc3M7IiwiY29uc3QgUmVzb3VyY2VzID0gcmVxdWlyZSgnLi4vcmVzb3VyY2VzL3Jlc291cmNlcy5qcycpLFxyXG4gICAgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy91dGlscy5qcycpLFxyXG4gICAgZ2FtZVByb2Nlc3MgPSByZXF1aXJlKCcuL2dhbWVQcm9jZXNzLmpzJyk7XHJcblxyXG4vLyBOb3cgd3JpdGUgeW91ciBvd24gcGxheWVyIGNsYXNzXHJcbi8vIFRoaXMgY2xhc3MgcmVxdWlyZXMgYW4gdXBkYXRlKCksIHJlbmRlcigpIGFuZFxyXG4vLyBhIGhhbmRsZUlucHV0KCkgbWV0aG9kLlxyXG52YXIgUGxheWVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnBsYXllckJvZHkgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLnBsYXllcklzQWN0aXZlID0gZmFsc2U7XHJcbiAgICB0aGlzLmxpdmVzID0gNTtcclxuICAgIHRoaXMuc2NvcmUgPSAwO1xyXG4gICAgdGhpcy5tYXhTY29yZSA9IDE1O1xyXG59O1xyXG5cclxuXHJcbi8vIEFkZCB0byBQbGF5ZXJib2R5KGltYWdlKSBhbmQgc2V0IGNvb3JkaW5hdGVzIGZvciBwbGF5ZXIgc3RhcnRcclxuUGxheWVyLnByb3RvdHlwZS5zZXRQbGF5ZXIgPSBmdW5jdGlvbihwbGF5ZXIpIHtcclxuICAgIHRoaXMucGxheWVyQm9keSA9IHBsYXllcjtcclxuICAgIHRoaXMueCA9IDEwMSAqIDI7XHJcbiAgICB0aGlzLnkgPSA4MyAqIDUgLSAzMjtcclxufTtcclxuXHJcbi8vIFJlZHVjZSBwbGF5ZXIgbGl2ZSBhbmQgcmV0dXJuIHBsYXllciB0byBzdGFydFxyXG5QbGF5ZXIucHJvdG90eXBlLmZhaWwgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMubGl2ZXMgLT0gMTtcclxuICAgIGlmICh0aGlzLmxpdmVzID4gMCkge1xyXG4gICAgICAgIHRoaXMucmV0dXJuVG9TdGFydCgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gQWRkIHBvaW50cyB0byBzY29yZSBhbmQgcmV0dXJuIHBsYXllciB0byBzdGFydFxyXG5QbGF5ZXIucHJvdG90eXBlLndpbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYodGhpcy5zY29yZSA8IHRoaXMubWF4U2NvcmUpe1xyXG4gICAgICAgIHRoaXMucmV0dXJuVG9TdGFydCgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gcmV0dXJuIHBsYXllciB0byBzdGFydFxyXG5QbGF5ZXIucHJvdG90eXBlLnJldHVyblRvU3RhcnQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLnggPSAxMDEgKiAyO1xyXG4gICAgICAgIHRoaXMueSA9IDgzICogNSAtIDMyO1xyXG59O1xyXG5cclxuLy8gQWRkIG9uZSBwb2ludCB0byBzY29yZVxyXG5QbGF5ZXIucHJvdG90eXBlLmluY3JlbWVudFNjb3JlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnNjb3JlICs9IDE7XHJcbn07XHJcblxyXG4vLyBTZXQgcGxheWVyIGFjdGl2ZVxyXG4vLyBUaGlzIHByb3BlcnR5IGJsb2NrcyB0aGUgc3RhcnQgYnV0dG9uIHRpbGwgcGxheWVyIGJvZHkoaW1hZ2UpIHdpbGwgYmUgc2V0XHJcblBsYXllci5wcm90b3R5cGUuYWN0aXZlUGxheWVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnBsYXllcklzQWN0aXZlID0gdHJ1ZTtcclxufTtcclxuXHJcbi8vIFJldHVybiB0cnVlIGlmIHBsYXllciBib2R5IGV4aXN0IGFuZCBcclxuUGxheWVyLnByb3RvdHlwZS5nZXRQbGF5ZXJBY3Rpdml0eSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucGxheWVySXNBY3RpdmU7XHJcbn07XHJcblxyXG5cclxuLy8gUmV0dXJuIHBsYXllcidzIGxpdmVzXHJcblBsYXllci5wcm90b3R5cGUuZ2V0TGl2ZXMgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmxpdmVzO1xyXG59O1xyXG5cclxuLy8gUmV0dXJuIHBsYXllcidzIHNjb3JlXHJcblBsYXllci5wcm90b3R5cGUuZ2V0U2NvcmUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnNjb3JlO1xyXG59O1xyXG5cclxuLy8gUmV0dXJuIGN1cnJlbnQgcGxheWVyIHBvc2l0aW9uXHJcblBsYXllci5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogdGhpcy54LFxyXG4gICAgICAgIHk6IHRoaXMueVxyXG4gICAgfTtcclxufTtcclxuXHJcbi8vIFNldCBkZWZhdWx0IHZhbHVlcyBmb3IgYWxsIHByb3BlcnRpZXMgaW4gY2xhc3NcclxuUGxheWVyLnByb3RvdHlwZS5yZXNldEFsbFZhbHVlcyA9IGZ1bmN0aW9uKCkge1xyXG4gICB0aGlzLnBsYXllckJvZHkgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLnBsYXllcklzQWN0aXZlID0gZmFsc2U7XHJcbiAgICB0aGlzLmxpdmVzID0gNTtcclxuICAgIHRoaXMuc2NvcmUgPSAwO1xyXG4gICAgdGhpcy5tYXhTY29yZSA9IDE1O1xyXG59O1xyXG5cclxuXHJcbi8vIE1hbmFnZSBwbGF5ZXIgbW92ZXNcclxuUGxheWVyLnByb3RvdHlwZS5oYW5kbGVJbnB1dCA9IGZ1bmN0aW9uKGNvZGUpIHtcclxuICAgIHN3aXRjaCAoY29kZSkge1xyXG4gICAgICAgIGNhc2UgJ3VwJzogLy8gaWYgKHggPT09ICd2YWx1ZTEnKVxyXG4gICAgICAgICAgICBpZiAodGhpcy55ID4gLTg0ICYmICh0aGlzLnkgLSA4MykgPiAtODQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMueSA9IHRoaXMueSAtIDgzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2Rvd24nOlxyXG4gICAgICAgICAgICBpZiAodGhpcy55IDwgODMgKiA1ICYmICh0aGlzLnkgKyA4MykgPCA4MyAqIDUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMueSA9IHRoaXMueSArIDgzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgICAgICAgaWYgKHRoaXMueCA+IC0xICYmICh0aGlzLnggKyAxMDEpIDwgMTAxICogNSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy54ID0gdGhpcy54ICsgMTAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2xlZnQnOlxyXG4gICAgICAgICAgICBpZiAodGhpcy54IDwgMTAxICogNSAmJiAodGhpcy54IC0gMTAxKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnggPSB0aGlzLnggLSAxMDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuLy8gVXBkYXRlIHBsYXllciBpbmZvIGFuZCBpZiBwbGF5ZXIgaXMgb24gdGhlIGZpbmlzaCB3YXRlciBsaW5lLCBhZGQgdG8gc2NvcmUgMSBwb2ludFxyXG4vLyByZXR1cm4gdGhlIHBsYXllciBvbiBzdGFydCBhbmQgaW5jcmVhc2UgdGhlIHNwZWVkIG9mIGVuZW1pZXNcclxuUGxheWVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihlbmVtaWVzKSB7XHJcbiAgICBpZiAodGhpcy55IDwgMCkge1xyXG4gICAgICAgIHRoaXMucmV0dXJuVG9TdGFydCgpO1xyXG4gICAgICAgIHRoaXMuaW5jcmVtZW50U2NvcmUoKTtcclxuICAgICAgICBlbmVtaWVzLmZvckVhY2goZnVuY3Rpb24oZW5lbXkpIHtcclxuICAgICAgICAgICAgZW5lbXkuaW5jcmVtZW50TGV2ZWwoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIERyYXcgdGhlIHBsYXllciBvbiB0aGUgc2NyZWVuLCByZXF1aXJlZCBtZXRob2QgZm9yIGdhbWVcclxuUGxheWVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihjb2RlKSB7XHJcbiAgICBjdHguZHJhd0ltYWdlKHRoaXMucGxheWVyQm9keSwgdGhpcy54LCB0aGlzLnkpO1xyXG59O1xyXG5cclxudmFyIHBsYXllciA9IG5ldyBQbGF5ZXIoKTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHBsYXllcjsiLCIvKiBFbmdpbmUuanNcclxuICogVGhpcyBmaWxlIHByb3ZpZGVzIHRoZSBnYW1lIGxvb3AgZnVuY3Rpb25hbGl0eSAodXBkYXRlIGVudGl0aWVzIGFuZCByZW5kZXIpLFxyXG4gKiBkcmF3cyB0aGUgaW5pdGlhbCBnYW1lIGJvYXJkIG9uIHRoZSBzY3JlZW4sIGFuZCB0aGVuIGNhbGxzIHRoZSB1cGRhdGUgYW5kXHJcbiAqIHJlbmRlciBtZXRob2RzIG9uIHlvdXIgcGxheWVyIGFuZCBlbmVteSBvYmplY3RzIChkZWZpbmVkIGluIHlvdXIgYXBwLmpzKS5cclxuICpcclxuICogQSBnYW1lIGVuZ2luZSB3b3JrcyBieSBkcmF3aW5nIHRoZSBlbnRpcmUgZ2FtZSBzY3JlZW4gb3ZlciBhbmQgb3Zlciwga2luZCBvZlxyXG4gKiBsaWtlIGEgZmxpcGJvb2sgeW91IG1heSBoYXZlIGNyZWF0ZWQgYXMgYSBraWQuIFdoZW4geW91ciBwbGF5ZXIgbW92ZXMgYWNyb3NzXHJcbiAqIHRoZSBzY3JlZW4sIGl0IG1heSBsb29rIGxpa2UganVzdCB0aGF0IGltYWdlL2NoYXJhY3RlciBpcyBtb3Zpbmcgb3IgYmVpbmdcclxuICogZHJhd24gYnV0IHRoYXQgaXMgbm90IHRoZSBjYXNlLiBXaGF0J3MgcmVhbGx5IGhhcHBlbmluZyBpcyB0aGUgZW50aXJlIFwic2NlbmVcIlxyXG4gKiBpcyBiZWluZyBkcmF3biBvdmVyIGFuZCBvdmVyLCBwcmVzZW50aW5nIHRoZSBpbGx1c2lvbiBvZiBhbmltYXRpb24uXHJcbiAqXHJcbiAqIFRoaXMgZW5naW5lIG1ha2VzIHRoZSBjYW52YXMnIGNvbnRleHQgKGN0eCkgb2JqZWN0IGdsb2JhbGx5IGF2YWlsYWJsZSB0byBtYWtlXHJcbiAqIHdyaXRpbmcgYXBwLmpzIGEgbGl0dGxlIHNpbXBsZXIgdG8gd29yayB3aXRoLlxyXG4gKi9cclxuXHJcblxyXG5jb25zdCBSZXNvdXJjZXMgPSByZXF1aXJlKCcuL3Jlc291cmNlcy5qcycpLFxyXG4gICAgZW5lbXlDbXAgPSByZXF1aXJlKCcuLi9wbGF5ZXJzL2VuZW15LmpzJyksXHJcbiAgICBwbGF5ZXJDbXAgPSByZXF1aXJlKCcuLi9wbGF5ZXJzL3BsYXllci5qcycpLFxyXG4gICAgZ2FtZVByb2Nlc3MgPSByZXF1aXJlKCcuLi9wbGF5ZXJzL2dhbWVQcm9jZXNzLmpzJyksXHJcbiAgICB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3V0aWxzLmpzJyk7XHJcblxyXG4vKiBQcmVkZWZpbmUgdGhlIHZhcmlhYmxlcyB3ZSdsbCBiZSB1c2luZyB3aXRoaW4gdGhpcyBzY29wZSxcclxuICogY3JlYXRlIHRoZSBjYW52YXMgZWxlbWVudCwgZ3JhYiB0aGUgMkQgY29udGV4dCBmb3IgdGhhdCBjYW52YXNcclxuICogc2V0IHRoZSBjYW52YXMgZWxlbWVudCdzIGhlaWdodC93aWR0aCBhbmQgYWRkIGl0IHRvIHRoZSBET00uXHJcbiAqL1xyXG5cclxudmFyIGRvYyA9IHdpbmRvdy5kb2N1bWVudCxcclxuICAgIHdpbiA9IHdpbmRvdy53aW5kb3csXHJcbiAgICBjYW52YXMgPSB1dGlscy5jcmVhdGVFbCgnY2FudmFzJyksXHJcbiAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcclxuICAgIG1haW5HYW1lQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21haW5HYW1lQ29udGFpbmVyJyksXHJcbiAgICBnYW1lSW5mb0VsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2dhbWVJbmZvJyksXHJcbiAgICBsYXN0VGltZSwgYWxsRW5lbWllcztcclxuXHJcbmNhbnZhcy53aWR0aCA9IDUwNTtcclxuY2FudmFzLmhlaWdodCA9IDYwNjtcclxubWFpbkdhbWVDb250YWluZXIuaW5zZXJ0QmVmb3JlKGNhbnZhcywgZ2FtZUluZm9FbCk7XHJcblxyXG4vKiBUaGlzIGZ1bmN0aW9uIHNlcnZlcyBhcyB0aGUga2lja29mZiBwb2ludCBmb3IgdGhlIGdhbWUgbG9vcCBpdHNlbGZcclxuICogYW5kIGhhbmRsZXMgcHJvcGVybHkgY2FsbGluZyB0aGUgdXBkYXRlIGFuZCByZW5kZXIgbWV0aG9kcy5cclxuICovXHJcbmZ1bmN0aW9uIG1haW4oKSB7XHJcbiAgICAvKiBHZXQgb3VyIHRpbWUgZGVsdGEgaW5mb3JtYXRpb24gd2hpY2ggaXMgcmVxdWlyZWQgaWYgeW91ciBnYW1lXHJcbiAgICAgKiByZXF1aXJlcyBzbW9vdGggYW5pbWF0aW9uLiBCZWNhdXNlIGV2ZXJ5b25lJ3MgY29tcHV0ZXIgcHJvY2Vzc2VzXHJcbiAgICAgKiBpbnN0cnVjdGlvbnMgYXQgZGlmZmVyZW50IHNwZWVkcyB3ZSBuZWVkIGEgY29uc3RhbnQgdmFsdWUgdGhhdFxyXG4gICAgICogd291bGQgYmUgdGhlIHNhbWUgZm9yIGV2ZXJ5b25lIChyZWdhcmRsZXNzIG9mIGhvdyBmYXN0IHRoZWlyXHJcbiAgICAgKiBjb21wdXRlciBpcykgLSBodXJyYXkgdGltZSFcclxuICAgICAqL1xyXG4gICAgdmFyIG5vdyA9IERhdGUubm93KCksXHJcbiAgICAgICAgZHQgPSAobm93IC0gbGFzdFRpbWUpIC8gMTAwMC4wO1xyXG5cclxuICAgIC8qIENhbGwgb3VyIHVwZGF0ZS9yZW5kZXIgZnVuY3Rpb25zLCBwYXNzIGFsb25nIHRoZSB0aW1lIGRlbHRhIHRvXHJcbiAgICAgKiBvdXIgdXBkYXRlIGZ1bmN0aW9uIHNpbmNlIGl0IG1heSBiZSB1c2VkIGZvciBzbW9vdGggYW5pbWF0aW9uLlxyXG4gICAgICovXHJcbiAgICB1cGRhdGUoZHQpO1xyXG4gICAgcmVuZGVyKCk7XHJcblxyXG4gICAgLyogU2V0IG91ciBsYXN0VGltZSB2YXJpYWJsZSB3aGljaCBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgdGltZSBkZWx0YVxyXG4gICAgICogZm9yIHRoZSBuZXh0IHRpbWUgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQuXHJcbiAgICAgKi9cclxuICAgIGxhc3RUaW1lID0gbm93O1xyXG5cclxuICAgIC8qIFVzZSB0aGUgYnJvd3NlcidzIHJlcXVlc3RBbmltYXRpb25GcmFtZSBmdW5jdGlvbiB0byBjYWxsIHRoaXNcclxuICAgICAqIGZ1bmN0aW9uIGFnYWluIGFzIHNvb24gYXMgdGhlIGJyb3dzZXIgaXMgYWJsZSB0byBkcmF3IGFub3RoZXIgZnJhbWUuXHJcbiAgICAgKi9cclxuICAgIGlmIChnYW1lUHJvY2Vzcy5nZXRHYW1lSW5Qcm9jZXNzKCkpIHtcclxuICAgICAgICB3aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1haW4pO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKiBUaGlzIGZ1bmN0aW9uIGRvZXMgc29tZSBpbml0aWFsIHNldHVwIHRoYXQgc2hvdWxkIG9ubHkgb2NjdXIgb25jZSxcclxuICogcGFydGljdWxhcmx5IHNldHRpbmcgdGhlIGxhc3RUaW1lIHZhcmlhYmxlIHRoYXQgaXMgcmVxdWlyZWQgZm9yIHRoZVxyXG4gKiBnYW1lIGxvb3AuXHJcbiAqL1xyXG5mdW5jdGlvbiBpbml0KCkge1xyXG4gICAgbGFzdFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgbWFpbigpO1xyXG59XHJcblxyXG4vKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSBtYWluIChvdXIgZ2FtZSBsb29wKSBhbmQgaXRzZWxmIGNhbGxzIGFsbFxyXG4gKiBvZiB0aGUgZnVuY3Rpb25zIHdoaWNoIG1heSBuZWVkIHRvIHVwZGF0ZSBlbnRpdHkncyBkYXRhLiBCYXNlZCBvbiBob3dcclxuICogeW91IGltcGxlbWVudCB5b3VyIGNvbGxpc2lvbiBkZXRlY3Rpb24gKHdoZW4gdHdvIGVudGl0aWVzIG9jY3VweSB0aGVcclxuICogc2FtZSBzcGFjZSwgZm9yIGluc3RhbmNlIHdoZW4geW91ciBjaGFyYWN0ZXIgc2hvdWxkIGRpZSksIHlvdSBtYXkgZmluZFxyXG4gKiB0aGUgbmVlZCB0byBhZGQgYW4gYWRkaXRpb25hbCBmdW5jdGlvbiBjYWxsIGhlcmUuIEZvciBub3csIHdlJ3ZlIGxlZnRcclxuICogaXQgY29tbWVudGVkIG91dCAtIHlvdSBtYXkgb3IgbWF5IG5vdCB3YW50IHRvIGltcGxlbWVudCB0aGlzXHJcbiAqIGZ1bmN0aW9uYWxpdHkgdGhpcyB3YXkgKHlvdSBjb3VsZCBqdXN0IGltcGxlbWVudCBjb2xsaXNpb24gZGV0ZWN0aW9uXHJcbiAqIG9uIHRoZSBlbnRpdGllcyB0aGVtc2VsdmVzIHdpdGhpbiB5b3VyIGFwcC5qcyBmaWxlKS5cclxuICovXHJcbmZ1bmN0aW9uIHVwZGF0ZShkdCkge1xyXG4gICAgZW5lbXlDbXAuYWxsRW5lbWllcy5mb3JFYWNoKGZ1bmN0aW9uKGVuZW15KSB7XHJcbiAgICAgICAgY29tcGFyZVBvc2l0aW9ucyhlbmVteSwgcGxheWVyQ21wKTtcclxuICAgIH0pO1xyXG4gICAgdXBkYXRlRW50aXRpZXMoZHQpO1xyXG59XHJcblxyXG4vKiBUaGlzIGlzIGNhbGxlZCBieSB0aGUgdXBkYXRlIGZ1bmN0aW9uIGFuZCBsb29wcyB0aHJvdWdoIGFsbCBvZiB0aGVcclxuICogb2JqZWN0cyB3aXRoaW4geW91ciBhbGxFbmVtaWVzIGFycmF5IGFzIGRlZmluZWQgaW4gYXBwLmpzIGFuZCBjYWxsc1xyXG4gKiB0aGVpciB1cGRhdGUoKSBtZXRob2RzLiBJdCB3aWxsIHRoZW4gY2FsbCB0aGUgdXBkYXRlIGZ1bmN0aW9uIGZvciB5b3VyXHJcbiAqIHBsYXllciBvYmplY3QuIFRoZXNlIHVwZGF0ZSBtZXRob2RzIHNob3VsZCBmb2N1cyBwdXJlbHkgb24gdXBkYXRpbmdcclxuICogdGhlIGRhdGEvcHJvcGVydGllcyByZWxhdGVkIHRvIHRoZSBvYmplY3QuIERvIHlvdXIgZHJhd2luZyBpbiB5b3VyXHJcbiAqIHJlbmRlciBtZXRob2RzLlxyXG4gKi9cclxuZnVuY3Rpb24gdXBkYXRlRW50aXRpZXMoZHQpIHtcclxuICAgIGVuZW15Q21wLmFsbEVuZW1pZXMuZm9yRWFjaChmdW5jdGlvbihlbmVteSkge1xyXG4gICAgICAgIGVuZW15LnVwZGF0ZShkdCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBwbGF5ZXJDbXAudXBkYXRlKGVuZW15Q21wLmFsbEVuZW1pZXMpO1xyXG5cclxuICAgIGlmIChwbGF5ZXJDbXAuZ2V0U2NvcmUoKSA+PSAxNSkge1xyXG4gICAgICAgIHJlc2V0KCdZb3Ugd2luIScpO1xyXG4gICAgfSBlbHNlIGlmIChwbGF5ZXJDbXAuZ2V0TGl2ZXMoKSA8PSAwKSB7XHJcbiAgICAgICAgcmVzZXQoJ1NvcnJ5LCB5b3UgbG9zZSEnKTtcclxuICAgIH1cclxufVxyXG5cclxuLyogVGhpcyBmdW5jdGlvbiBpbml0aWFsbHkgZHJhd3MgdGhlIFwiZ2FtZSBsZXZlbFwiLCBpdCB3aWxsIHRoZW4gY2FsbFxyXG4gKiB0aGUgcmVuZGVyRW50aXRpZXMgZnVuY3Rpb24uIFJlbWVtYmVyLCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBldmVyeVxyXG4gKiBnYW1lIHRpY2sgKG9yIGxvb3Agb2YgdGhlIGdhbWUgZW5naW5lKSBiZWNhdXNlIHRoYXQncyBob3cgZ2FtZXMgd29yayAtXHJcbiAqIHRoZXkgYXJlIGZsaXBib29rcyBjcmVhdGluZyB0aGUgaWxsdXNpb24gb2YgYW5pbWF0aW9uIGJ1dCBpbiByZWFsaXR5XHJcbiAqIHRoZXkgYXJlIGp1c3QgZHJhd2luZyB0aGUgZW50aXJlIHNjcmVlbiBvdmVyIGFuZCBvdmVyLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gICAgLyogVGhpcyBhcnJheSBob2xkcyB0aGUgcmVsYXRpdmUgVVJMIHRvIHRoZSBpbWFnZSB1c2VkXHJcbiAgICAgKiBmb3IgdGhhdCBwYXJ0aWN1bGFyIHJvdyBvZiB0aGUgZ2FtZSBsZXZlbC5cclxuICAgICAqL1xyXG4gICAgdmFyIHJvd0ltYWdlcyA9IFtcclxuICAgICAgICAgICAgJ2ltYWdlcy93YXRlci1ibG9jay5wbmcnLCAvLyBUb3Agcm93IGlzIHdhdGVyXHJcbiAgICAgICAgICAgICdpbWFnZXMvc3RvbmUtYmxvY2sucG5nJywgLy8gUm93IDEgb2YgMyBvZiBzdG9uZVxyXG4gICAgICAgICAgICAnaW1hZ2VzL3N0b25lLWJsb2NrLnBuZycsIC8vIFJvdyAyIG9mIDMgb2Ygc3RvbmVcclxuICAgICAgICAgICAgJ2ltYWdlcy9zdG9uZS1ibG9jay5wbmcnLCAvLyBSb3cgMyBvZiAzIG9mIHN0b25lXHJcbiAgICAgICAgICAgICdpbWFnZXMvZ3Jhc3MtYmxvY2sucG5nJywgLy8gUm93IDEgb2YgMiBvZiBncmFzc1xyXG4gICAgICAgICAgICAnaW1hZ2VzL2dyYXNzLWJsb2NrLnBuZycgLy8gUm93IDIgb2YgMiBvZiBncmFzc1xyXG4gICAgICAgIF0sXHJcbiAgICAgICAgbnVtUm93cyA9IDYsXHJcbiAgICAgICAgbnVtQ29scyA9IDUsXHJcbiAgICAgICAgcm93LCBjb2w7XHJcblxyXG4gICAgLy8gQmVmb3JlIGRyYXdpbmcsIGNsZWFyIGV4aXN0aW5nIGNhbnZhc1xyXG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG5cclxuICAgIC8qIExvb3AgdGhyb3VnaCB0aGUgbnVtYmVyIG9mIHJvd3MgYW5kIGNvbHVtbnMgd2UndmUgZGVmaW5lZCBhYm92ZVxyXG4gICAgICogYW5kLCB1c2luZyB0aGUgcm93SW1hZ2VzIGFycmF5LCBkcmF3IHRoZSBjb3JyZWN0IGltYWdlIGZvciB0aGF0XHJcbiAgICAgKiBwb3J0aW9uIG9mIHRoZSBcImdyaWRcIlxyXG4gICAgICovXHJcbiAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IG51bVJvd3M7IHJvdysrKSB7XHJcbiAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCBudW1Db2xzOyBjb2wrKykge1xyXG4gICAgICAgICAgICAvKiBUaGUgZHJhd0ltYWdlIGZ1bmN0aW9uIG9mIHRoZSBjYW52YXMnIGNvbnRleHQgZWxlbWVudFxyXG4gICAgICAgICAgICAgKiByZXF1aXJlcyAzIHBhcmFtZXRlcnM6IHRoZSBpbWFnZSB0byBkcmF3LCB0aGUgeCBjb29yZGluYXRlXHJcbiAgICAgICAgICAgICAqIHRvIHN0YXJ0IGRyYXdpbmcgYW5kIHRoZSB5IGNvb3JkaW5hdGUgdG8gc3RhcnQgZHJhd2luZy5cclxuICAgICAgICAgICAgICogV2UncmUgdXNpbmcgb3VyIFJlc291cmNlcyBoZWxwZXJzIHRvIHJlZmVyIHRvIG91ciBpbWFnZXNcclxuICAgICAgICAgICAgICogc28gdGhhdCB3ZSBnZXQgdGhlIGJlbmVmaXRzIG9mIGNhY2hpbmcgdGhlc2UgaW1hZ2VzLCBzaW5jZVxyXG4gICAgICAgICAgICAgKiB3ZSdyZSB1c2luZyB0aGVtIG92ZXIgYW5kIG92ZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKFJlc291cmNlcy5nZXQocm93SW1hZ2VzW3Jvd10pLCBjb2wgKiAxMDEsIHJvdyAqIDgzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyRW50aXRpZXMoKTtcclxuICAgIGdhbWVQcm9jZXNzLnVwZGF0ZShwbGF5ZXJDbXAsIGVuZW15Q21wLmFsbEVuZW1pZXNbMF0pO1xyXG59XHJcblxyXG4vKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGFuZCBpcyBjYWxsZWQgb24gZWFjaCBnYW1lXHJcbiAqIHRpY2suIEl0cyBwdXJwb3NlIGlzIHRvIHRoZW4gY2FsbCB0aGUgcmVuZGVyIGZ1bmN0aW9ucyB5b3UgaGF2ZSBkZWZpbmVkXHJcbiAqIG9uIHlvdXIgZW5lbXkgYW5kIHBsYXllciBlbnRpdGllcyB3aXRoaW4gYXBwLmpzXHJcbiAqL1xyXG5mdW5jdGlvbiByZW5kZXJFbnRpdGllcygpIHtcclxuICAgIC8qIExvb3AgdGhyb3VnaCBhbGwgb2YgdGhlIG9iamVjdHMgd2l0aGluIHRoZSBhbGxFbmVtaWVzIGFycmF5IGFuZCBjYWxsXHJcbiAgICAgKiB0aGUgcmVuZGVyIGZ1bmN0aW9uIHlvdSBoYXZlIGRlZmluZWQuXHJcbiAgICAgKi9cclxuICAgIGVuZW15Q21wLmFsbEVuZW1pZXMuZm9yRWFjaChmdW5jdGlvbihlbmVteSkge1xyXG4gICAgICAgIGVuZW15LnJlbmRlcigpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcGxheWVyQ21wLnJlbmRlcigpO1xyXG59XHJcblxyXG5cclxuLy8gQ29tcGFyZSBwb3NpdGlvbnMgb2YgZW5lbWllcyBhbmQgcGxheWVyXHJcbi8vIElmIHBsYXllciBtZWV0IGVuZW15IHRoYW4gd2lsbCBiZSBjYWxsZWQgcGxheWVyIG1ldGhvZCB7I1BsYXllci5mYWlsfVxyXG5mdW5jdGlvbiBjb21wYXJlUG9zaXRpb25zKGVuZW15LCBwbGF5ZXIpIHtcclxuICAgIGxldCBwbGF5ZXJQb3MgPSBwbGF5ZXIuZ2V0UG9zaXRpb24oKSxcclxuICAgICAgICBlbmVteVBvcyA9IGVuZW15LmdldFBvc2l0aW9uKCksXHJcbiAgICAgICAgcGxheWVyTGVmdCwgcGxheWVyUmlnaHQsIHBsYXllclRvcCxcclxuICAgICAgICBlbmVteUxlZnQsIGVuZW15UmlnaHQsIGVuZW15Qm90dG9tLFxyXG4gICAgICAgIGNvbXBhcmVMZXZlbEhpZ2g7XHJcblxyXG4gICAgcGxheWVyTGVmdCA9IHBsYXllci54O1xyXG4gICAgcGxheWVyUmlnaHQgPSBwbGF5ZXIueCArIDEwMTtcclxuICAgIHBsYXllclRvcCA9IHBsYXllci55ICsgNzA7XHJcblxyXG4gICAgZW5lbXlMZWZ0ID0gZW5lbXlQb3MueCArIDQwO1xyXG4gICAgZW5lbXlSaWdodCA9IGVuZW15UG9zLnggKyA2MTtcclxuICAgIGVuZW15Qm90dG9tID0gZW5lbXlQb3MueSArIDE3MTtcclxuICAgIGVuZW15VG9wID0gZW5lbXlQb3MueSArIDcwO1xyXG5cclxuICAgIGNvbXBhcmVMZXZlbEhpZ2ggPSBNYXRoLmNlaWwocGxheWVyVG9wIC8gMTApID09PSBNYXRoLmNlaWwoZW5lbXlUb3AgLyAxMCk7XHJcblxyXG4gICAgaWYgKHBsYXllckxlZnQgPCBlbmVteVJpZ2h0ICYmIHBsYXllclJpZ2h0ID4gZW5lbXlMZWZ0ICYmIGNvbXBhcmVMZXZlbEhpZ2gpIHtcclxuICAgICAgICBwbGF5ZXJDbXAuZmFpbCgpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90aGluZyBidXQgaXQgY291bGQgaGF2ZSBiZWVuIGEgZ29vZCBwbGFjZSB0b1xyXG4gKiBoYW5kbGUgZ2FtZSByZXNldCBzdGF0ZXMgLSBtYXliZSBhIG5ldyBnYW1lIG1lbnUgb3IgYSBnYW1lIG92ZXIgc2NyZWVuXHJcbiAqIHRob3NlIHNvcnRzIG9mIHRoaW5ncy4gSXQncyBvbmx5IGNhbGxlZCBvbmNlIGJ5IHRoZSBpbml0KCkgbWV0aG9kLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVzZXQocmVzdWx0KSB7XHJcbiAgICBnYW1lUHJvY2Vzcy5zZXRHYW1lSW5Qcm9jZXNzKGZhbHNlKTtcclxuICAgIGdhbWVQcm9jZXNzLmNsZWFyR2FtZUJvYXJkKGNhbnZhcyk7XHJcbiAgICBnYW1lUHJvY2Vzcy5nYW1lSW5mb1Zpc2liaWxpdHkoKTtcclxuICAgIGdhbWVQcm9jZXNzLmdhbWVFbmRNb2RhbChyZXN1bHQpO1xyXG59XHJcblxyXG4vKiBHbyBhaGVhZCBhbmQgbG9hZCBhbGwgb2YgdGhlIGltYWdlcyB3ZSBrbm93IHdlJ3JlIGdvaW5nIHRvIG5lZWQgdG9cclxuICogZHJhdyBvdXIgZ2FtZSBsZXZlbC4gVGhlbiBzZXQgaW5pdCBhcyB0aGUgY2FsbGJhY2sgbWV0aG9kLCBzbyB0aGF0IHdoZW5cclxuICogYWxsIG9mIHRoZXNlIGltYWdlcyBhcmUgcHJvcGVybHkgbG9hZGVkIG91ciBnYW1lIHdpbGwgc3RhcnQuXHJcbiAqL1xyXG5SZXNvdXJjZXMubG9hZChbXHJcbiAgICAvLyBNYXAgc291cmNlc1xyXG4gICAgJ2ltYWdlcy9zdG9uZS1ibG9jay5wbmcnLFxyXG4gICAgJ2ltYWdlcy93YXRlci1ibG9jay5wbmcnLFxyXG4gICAgJ2ltYWdlcy9ncmFzcy1ibG9jay5wbmcnLFxyXG4gICAgLy8gRW5lbXkgc291cmNlXHJcbiAgICAnaW1hZ2VzL2VuZW15LWJ1Zy5wbmcnLFxyXG4gICAgLy8gQm9udXNlcyBzb3VyY2VzXHJcbiAgICAnaW1hZ2VzL0dlbV9CbHVlLnBuZycsXHJcbiAgICAnaW1hZ2VzL0dlbV9HcmVlbi5wbmcnLFxyXG4gICAgJ2ltYWdlcy9HZW1fT3JhbmdlLnBuZycsXHJcbiAgICAvLyBQbGF5ZXIgc291cmNlc1xyXG4gICAgJ2ltYWdlcy9jaGFyLWJveS5wbmcnLFxyXG4gICAgJ2ltYWdlcy9jaGFyLWNhdC1naXJsLnBuZycsXHJcbiAgICAnaW1hZ2VzL2NoYXItaG9ybi1naXJsLnBuZycsXHJcbiAgICAnaW1hZ2VzL2NoYXItcGluay1naXJsLnBuZycsXHJcbiAgICAnaW1hZ2VzL2NoYXItcHJpbmNlc3MtZ2lybC5wbmcnXHJcbl0pO1xyXG4vLyBSZXNvdXJjZXMub25SZWFkeShpbml0KTtcclxuUmVzb3VyY2VzLm9uUmVhZHkoZ2FtZVByb2Nlc3MuYWRkUGxheWVyc1RvTW9kYWxTdGFydCk7XHJcblxyXG4vKiBBc3NpZ24gdGhlIGNhbnZhcycgY29udGV4dCBvYmplY3QgdG8gdGhlIGdsb2JhbCB2YXJpYWJsZSAodGhlIHdpbmRvd1xyXG4gKiBvYmplY3Qgd2hlbiBydW4gaW4gYSBicm93c2VyKSBzbyB0aGF0IGRldmVsb3BlcnMgY2FuIHVzZSBpdCBtb3JlIGVhc2lseVxyXG4gKiBmcm9tIHdpdGhpbiB0aGVpciBhcHAuanMgZmlsZXMuXHJcbiAqL1xyXG53aW5kb3cuY3R4ID0gY3R4O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBpbml0R2FtZTogaW5pdCxcclxuICAgIHJlc2V0R2FtZTogcmVzZXQsXHJcbiAgICBtYWluOiBtYWluXHJcbn07IiwiLyogUmVzb3VyY2VzLmpzXHJcbiAqIFRoaXMgaXMgc2ltcGx5IGFuIGltYWdlIGxvYWRpbmcgdXRpbGl0eS4gSXQgZWFzZXMgdGhlIHByb2Nlc3Mgb2YgbG9hZGluZ1xyXG4gKiBpbWFnZSBmaWxlcyBzbyB0aGF0IHRoZXkgY2FuIGJlIHVzZWQgd2l0aGluIHlvdXIgZ2FtZS4gSXQgYWxzbyBpbmNsdWRlc1xyXG4gKiBhIHNpbXBsZSBcImNhY2hpbmdcIiBsYXllciBzbyBpdCB3aWxsIHJldXNlIGNhY2hlZCBpbWFnZXMgaWYgeW91IGF0dGVtcHRcclxuICogdG8gbG9hZCB0aGUgc2FtZSBpbWFnZSBtdWx0aXBsZSB0aW1lcy5cclxuICovXHJcbnZhciBSZXNvdXJjZXMgPSAoZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcmVzb3VyY2VDYWNoZSA9IHt9O1xyXG4gICAgdmFyIHJlYWR5Q2FsbGJhY2tzID0gW107XHJcblxyXG4gICAgLyogVGhpcyBpcyB0aGUgcHVibGljbHkgYWNjZXNzaWJsZSBpbWFnZSBsb2FkaW5nIGZ1bmN0aW9uLiBJdCBhY2NlcHRzXHJcbiAgICAgKiBhbiBhcnJheSBvZiBzdHJpbmdzIHBvaW50aW5nIHRvIGltYWdlIGZpbGVzIG9yIGEgc3RyaW5nIGZvciBhIHNpbmdsZVxyXG4gICAgICogaW1hZ2UuIEl0IHdpbGwgdGhlbiBjYWxsIG91ciBwcml2YXRlIGltYWdlIGxvYWRpbmcgZnVuY3Rpb24gYWNjb3JkaW5nbHkuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGxvYWQodXJsT3JBcnIpIHtcclxuICAgICAgICBpZih1cmxPckFyciBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgIC8qIElmIHRoZSBkZXZlbG9wZXIgcGFzc2VkIGluIGFuIGFycmF5IG9mIGltYWdlc1xyXG4gICAgICAgICAgICAgKiBsb29wIHRocm91Z2ggZWFjaCB2YWx1ZSBhbmQgY2FsbCBvdXIgaW1hZ2VcclxuICAgICAgICAgICAgICogbG9hZGVyIG9uIHRoYXQgaW1hZ2UgZmlsZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdXJsT3JBcnIuZm9yRWFjaChmdW5jdGlvbih1cmwpIHtcclxuICAgICAgICAgICAgICAgIF9sb2FkKHVybCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8qIFRoZSBkZXZlbG9wZXIgZGlkIG5vdCBwYXNzIGFuIGFycmF5IHRvIHRoaXMgZnVuY3Rpb24sXHJcbiAgICAgICAgICAgICAqIGFzc3VtZSB0aGUgdmFsdWUgaXMgYSBzdHJpbmcgYW5kIGNhbGwgb3VyIGltYWdlIGxvYWRlclxyXG4gICAgICAgICAgICAgKiBkaXJlY3RseS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF9sb2FkKHVybE9yQXJyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyogVGhpcyBpcyBvdXIgcHJpdmF0ZSBpbWFnZSBsb2FkZXIgZnVuY3Rpb24sIGl0IGlzXHJcbiAgICAgKiBjYWxsZWQgYnkgdGhlIHB1YmxpYyBpbWFnZSBsb2FkZXIgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9sb2FkKHVybCkge1xyXG4gICAgICAgIGlmKHJlc291cmNlQ2FjaGVbdXJsXSkge1xyXG4gICAgICAgICAgICAvKiBJZiB0aGlzIFVSTCBoYXMgYmVlbiBwcmV2aW91c2x5IGxvYWRlZCBpdCB3aWxsIGV4aXN0IHdpdGhpblxyXG4gICAgICAgICAgICAgKiBvdXIgcmVzb3VyY2VDYWNoZSBhcnJheS4gSnVzdCByZXR1cm4gdGhhdCBpbWFnZSByYXRoZXIgdGhhblxyXG4gICAgICAgICAgICAgKiByZS1sb2FkaW5nIHRoZSBpbWFnZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHJldHVybiByZXNvdXJjZUNhY2hlW3VybF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLyogVGhpcyBVUkwgaGFzIG5vdCBiZWVuIHByZXZpb3VzbHkgbG9hZGVkIGFuZCBpcyBub3QgcHJlc2VudFxyXG4gICAgICAgICAgICAgKiB3aXRoaW4gb3VyIGNhY2hlOyB3ZSdsbCBuZWVkIHRvIGxvYWQgdGhpcyBpbWFnZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgLyogT25jZSBvdXIgaW1hZ2UgaGFzIHByb3Blcmx5IGxvYWRlZCwgYWRkIGl0IHRvIG91ciBjYWNoZVxyXG4gICAgICAgICAgICAgICAgICogc28gdGhhdCB3ZSBjYW4gc2ltcGx5IHJldHVybiB0aGlzIGltYWdlIGlmIHRoZSBkZXZlbG9wZXJcclxuICAgICAgICAgICAgICAgICAqIGF0dGVtcHRzIHRvIGxvYWQgdGhpcyBmaWxlIGluIHRoZSBmdXR1cmUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHJlc291cmNlQ2FjaGVbdXJsXSA9IGltZztcclxuXHJcbiAgICAgICAgICAgICAgICAvKiBPbmNlIHRoZSBpbWFnZSBpcyBhY3R1YWxseSBsb2FkZWQgYW5kIHByb3Blcmx5IGNhY2hlZCxcclxuICAgICAgICAgICAgICAgICAqIGNhbGwgYWxsIG9mIHRoZSBvblJlYWR5KCkgY2FsbGJhY2tzIHdlIGhhdmUgZGVmaW5lZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgaWYoaXNSZWFkeSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZHlDYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbihmdW5jKSB7IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jLmNhbGwoKTsgXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKiBTZXQgdGhlIGluaXRpYWwgY2FjaGUgdmFsdWUgdG8gZmFsc2UsIHRoaXMgd2lsbCBjaGFuZ2Ugd2hlblxyXG4gICAgICAgICAgICAgKiB0aGUgaW1hZ2UncyBvbmxvYWQgZXZlbnQgaGFuZGxlciBpcyBjYWxsZWQuIEZpbmFsbHksIHBvaW50XHJcbiAgICAgICAgICAgICAqIHRoZSBpbWFnZSdzIHNyYyBhdHRyaWJ1dGUgdG8gdGhlIHBhc3NlZCBpbiBVUkwuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICByZXNvdXJjZUNhY2hlW3VybF0gPSBmYWxzZTtcclxuICAgICAgICAgICAgaW1nLnNyYyA9IHVybDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyogVGhpcyBpcyB1c2VkIGJ5IGRldmVsb3BlcnMgdG8gZ3JhYiByZWZlcmVuY2VzIHRvIGltYWdlcyB0aGV5IGtub3dcclxuICAgICAqIGhhdmUgYmVlbiBwcmV2aW91c2x5IGxvYWRlZC4gSWYgYW4gaW1hZ2UgaXMgY2FjaGVkLCB0aGlzIGZ1bmN0aW9uc1xyXG4gICAgICogdGhlIHNhbWUgYXMgY2FsbGluZyBsb2FkKCkgb24gdGhhdCBVUkwuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldCh1cmwpIHtcclxuICAgICAgICByZXR1cm4gcmVzb3VyY2VDYWNoZVt1cmxdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qIFRoaXMgZnVuY3Rpb24gZGV0ZXJtaW5lcyBpZiBhbGwgb2YgdGhlIGltYWdlcyB0aGF0IGhhdmUgYmVlbiByZXF1ZXN0ZWRcclxuICAgICAqIGZvciBsb2FkaW5nIGhhdmUgaW4gZmFjdCBiZWVuIHByb3Blcmx5IGxvYWRlZC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNSZWFkeSgpIHtcclxuICAgICAgICB2YXIgcmVhZHkgPSB0cnVlO1xyXG4gICAgICAgIGZvcih2YXIgayBpbiByZXNvdXJjZUNhY2hlKSB7XHJcbiAgICAgICAgICAgIGlmKHJlc291cmNlQ2FjaGUuaGFzT3duUHJvcGVydHkoaykgJiZcclxuICAgICAgICAgICAgICAgIXJlc291cmNlQ2FjaGVba10pIHtcclxuICAgICAgICAgICAgICAgIHJlYWR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlYWR5O1xyXG4gICAgfVxyXG5cclxuICAgIC8qIFRoaXMgZnVuY3Rpb24gd2lsbCBhZGQgYSBmdW5jdGlvbiB0byB0aGUgY2FsbGJhY2sgc3RhY2sgdGhhdCBpcyBjYWxsZWRcclxuICAgICAqIHdoZW4gYWxsIHJlcXVlc3RlZCBpbWFnZXMgYXJlIHByb3Blcmx5IGxvYWRlZC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb25SZWFkeShmdW5jKSB7XHJcbiAgICAgICAgcmVhZHlDYWxsYmFja3MucHVzaChmdW5jKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiBUaGlzIG9iamVjdCBkZWZpbmVzIHRoZSBwdWJsaWNseSBhY2Nlc3NpYmxlIGZ1bmN0aW9ucyBhdmFpbGFibGUgdG9cclxuICAgICAqIGRldmVsb3BlcnMgYnkgY3JlYXRpbmcgYSBnbG9iYWwgUmVzb3VyY2VzIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBsb2FkOiBsb2FkLFxyXG4gICAgICAgIGdldDogZ2V0LFxyXG4gICAgICAgIG9uUmVhZHk6IG9uUmVhZHksXHJcbiAgICAgICAgaXNSZWFkeTogaXNSZWFkeVxyXG4gICAgfTtcclxufSkoKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVzb3VyY2VzO1xyXG4iLCIvKipcclxuICogQGRlc2NyaXB0aW9uIFRvZ2dsZSBnaXZlbiBjbGFzcyB1c2luZyBjcm9zcyBicm93c2VyIHByb3BlcnR5IENsYXNzTmFtZS5cclxuICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgRE9NRWxlbWVudCB0byB0b2dnbGUgY2xhc3MuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWUgQ2xhc3MgbmFtZSB0aGF0IHNob3VsZCBiZSB0b2dnbGVkLlxyXG4gKi9cclxuLy8gdG9nZ2xlQ2xhc3MgZnVuY3Rpb24gZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODg4MDg5MC9ob3ctZG8taS10b2dnbGUtYW4tZWxlbWVudHMtY2xhc3MtaW4tcHVyZS1qYXZhc2NyaXB0XHJcbmZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xyXG4gICAgaWYgKCFlbGVtZW50IHx8ICFjbGFzc05hbWUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNsYXNzU3RyaW5nID0gZWxlbWVudC5jbGFzc05hbWUsXHJcbiAgICAgICAgbmFtZUluZGV4ID0gY2xhc3NTdHJpbmcuaW5kZXhPZihjbGFzc05hbWUpO1xyXG4gICAgaWYgKG5hbWVJbmRleCA9PSAtMSkge1xyXG4gICAgICAgIGNsYXNzU3RyaW5nICs9ICcgJyArIGNsYXNzTmFtZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2xhc3NTdHJpbmcgPSBjbGFzc1N0cmluZy5zdWJzdHIoMCwgbmFtZUluZGV4KSArIGNsYXNzU3RyaW5nLnN1YnN0cihuYW1lSW5kZXggKyBjbGFzc05hbWUubGVuZ3RoKTtcclxuICAgIH1cclxuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gY2xhc3NTdHJpbmc7XHJcbn1cclxuXHJcbi8vIFNob3J0Y3V0IGZvciBjcmVhdGUgZWxlbWVudFxyXG5mdW5jdGlvbiBjcmVhdGVFbCh0YWcpe1xyXG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICB0b2dnbGVDbGFzczogdG9nZ2xlQ2xhc3MsXHJcbiAgICBjcmVhdGVFbDogY3JlYXRlRWxcclxufTsiXX0=
