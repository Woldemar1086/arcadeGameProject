{"version":3,"sources":["arcadegame.min.js"],"names":["Enemy","this","sprite","x","y","prototype","update","dt","render","ctx","drawImage","Resources","get","speed","console","log","Player","playerBody","undefined","setPlayer","player","handleInput","code","allEnemies","document","addEventListener","e","37","38","39","40","keyCode","Engine","global","require","modalActions","doc","window","win","canvas","createElement","getContext","startPlayButton","querySelectorAll","main","now","Date","row","col","rowImages","clearRect","width","height","requestAnimationFrame","body","appendChild","load","onReady","addPlayersToModalStart","closeModalStart","stop","resourceCache","readyCallbacks","_load","url","img","Image","onload","isReady","forEach","func","call","src","ready","k","hasOwnProperty","urlOrArr","Array","push","module","exports","utils","allPlayers","allKeysForPlayers","modalWindow","playerContainer","i","j","len","lenJ","modalPlayers","getElementById","length","playerContainerText","className","indexOf","toLowerCase","dataset","bodyType","textContent","toggleClass","element","classString","nameIndex","substr"],"mappings":"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","sourcesContent":["// Enemies our player must avoid\r\nvar Enemy = function() {\r\n    // Variables applied to each of our instances go here,\r\n    // we've provided one for you to get started\r\n\r\n    // The image/sprite for our enemies, this uses\r\n    // a helper we've provided to easily load images\r\n    this.sprite = 'images/enemy-bug.png';\r\n    this.x = null;\r\n    this.y = null;\r\n};\r\n\r\n// Update the enemy's position, required method for game\r\n// Parameter: dt, a time delta between ticks\r\nEnemy.prototype.update = function(dt) {\r\n    // You should multiply any movement by the dt parameter\r\n    // which will ensure the game runs at the same speed for\r\n    // all computers.\r\n    this.render(dt);\r\n};\r\n\r\n// Draw the enemy on the screen, required method for game\r\nEnemy.prototype.render = function() {\r\n    ctx.drawImage(Resources.get(this.sprite), this.x, this.y);\r\n};\r\n\r\nEnemy.prototype.speed = function() {\r\n    console.log(speed);\r\n};\r\n\r\n\r\n// Now write your own player class\r\n// This class requires an update(), render() and\r\n// a handleInput() method.\r\n\r\nvar Player = function () {\r\n\tthis.playerBody = undefined;\r\n};\r\n\r\nPlayer.prototype.setPlayer = function (player) {\r\n\tthis.playerBody = player;\r\n};\r\n\r\nPlayer.prototype.handleInput = function (code) {\r\n\tconsole.log(code);\r\n};\r\n\r\nPlayer.prototype.update = function (code) {\r\n\tconsole.log(code);\r\n};\r\n\r\nvar player = new Player();\r\n// Now instantiate your objects.\r\n// Place all enemy objects in an array called allEnemies\r\n// Place the player object in a variable called player\r\n\r\nvar allEnemies = [];\r\n\r\n\r\n// This listens for key presses and sends the keys to your\r\n// Player.handleInput() method. You don't need to modify this.\r\ndocument.addEventListener('keyup', function(e) {\r\n    var allowedKeys = {\r\n        37: 'left',\r\n        38: 'up',\r\n        39: 'right',\r\n        40: 'down'\r\n    };\r\n\r\n    player.handleInput(allowedKeys[e.keyCode]);\r\n});\r\n;/* Engine.js\r\n * This file provides the game loop functionality (update entities and render),\r\n * draws the initial game board on the screen, and then calls the update and\r\n * render methods on your player and enemy objects (defined in your app.js).\r\n *\r\n * A game engine works by drawing the entire game screen over and over, kind of\r\n * like a flipbook you may have created as a kid. When your player moves across\r\n * the screen, it may look like just that image/character is moving or being\r\n * drawn but that is not the case. What's really happening is the entire \"scene\"\r\n * is being drawn over and over, presenting the illusion of animation.\r\n *\r\n * This engine makes the canvas' context (ctx) object globally available to make\r\n * writing app.js a little simpler to work with.\r\n */\r\n\r\nvar Engine = (function(global) {\r\n    const Resources = require('./resources.js'),\r\n          modalActions = require('./startGame.js');\r\n\r\n    /* Predefine the variables we'll be using within this scope,\r\n     * create the canvas element, grab the 2D context for that canvas\r\n     * set the canvas element's height/width and add it to the DOM.\r\n     */\r\n\r\n    var doc = window.document,\r\n        win = window.window,\r\n        canvas = doc.createElement('canvas'),\r\n        ctx = canvas.getContext('2d'),\r\n        startPlayButton = document.querySelectorAll('.modalStart__button')[0],\r\n        lastTime, allEnemies;\r\n\r\n    canvas.width = 505;\r\n    canvas.height = 606;\r\n    doc.body.appendChild(canvas);\r\n\r\n    /* This function serves as the kickoff point for the game loop itself\r\n     * and handles properly calling the update and render methods.\r\n     */\r\n    function main() {\r\n        /* Get our time delta information which is required if your game\r\n         * requires smooth animation. Because everyone's computer processes\r\n         * instructions at different speeds we need a constant value that\r\n         * would be the same for everyone (regardless of how fast their\r\n         * computer is) - hurray time!\r\n         */\r\n        var now = Date.now(),\r\n            dt = (now - lastTime) / 1000.0;\r\n\r\n        /* Call our update/render functions, pass along the time delta to\r\n         * our update function since it may be used for smooth animation.\r\n         */\r\n        update(dt);\r\n        render();\r\n\r\n        /* Set our lastTime variable which is used to determine the time delta\r\n         * for the next time this function is called.\r\n         */\r\n        lastTime = now;\r\n        // console.log(dt)\r\n        /* Use the browser's requestAnimationFrame function to call this\r\n         * function again as soon as the browser is able to draw another frame.\r\n         */\r\n        win.requestAnimationFrame(main);\r\n    }\r\n\r\n    /* This function does some initial setup that should only occur once,\r\n     * particularly setting the lastTime variable that is required for the\r\n     * game loop.\r\n     */\r\n    function init() {\r\n        if (!stop) {\r\n            reset();\r\n        }\r\n        lastTime = Date.now();\r\n        main();\r\n    }\r\n\r\n    /* This function is called by main (our game loop) and itself calls all\r\n     * of the functions which may need to update entity's data. Based on how\r\n     * you implement your collision detection (when two entities occupy the\r\n     * same space, for instance when your character should die), you may find\r\n     * the need to add an additional function call here. For now, we've left\r\n     * it commented out - you may or may not want to implement this\r\n     * functionality this way (you could just implement collision detection\r\n     * on the entities themselves within your app.js file).\r\n     */\r\n    function update(dt) {\r\n        // updateEntities(dt);\r\n        // checkCollisions();\r\n    }\r\n\r\n    /* This is called by the update function and loops through all of the\r\n     * objects within your allEnemies array as defined in app.js and calls\r\n     * their update() methods. It will then call the update function for your\r\n     * player object. These update methods should focus purely on updating\r\n     * the data/properties related to the object. Do your drawing in your\r\n     * render methods.\r\n     */\r\n    function updateEntities(dt) {\r\n        allEnemies.forEach(function(enemy) {\r\n            enemy.update(dt);\r\n        });\r\n        player.update();\r\n    }\r\n\r\n    /* This function initially draws the \"game level\", it will then call\r\n     * the renderEntities function. Remember, this function is called every\r\n     * game tick (or loop of the game engine) because that's how games work -\r\n     * they are flipbooks creating the illusion of animation but in reality\r\n     * they are just drawing the entire screen over and over.\r\n     */\r\n    function render() {\r\n        /* This array holds the relative URL to the image used\r\n         * for that particular row of the game level.\r\n         */\r\n        var rowImages = [\r\n                'images/water-block.png', // Top row is water\r\n                'images/stone-block.png', // Row 1 of 3 of stone\r\n                'images/stone-block.png', // Row 2 of 3 of stone\r\n                'images/stone-block.png', // Row 3 of 3 of stone\r\n                'images/grass-block.png', // Row 1 of 2 of grass\r\n                'images/grass-block.png' // Row 2 of 2 of grass\r\n            ],\r\n            numRows = 6,\r\n            numCols = 5,\r\n            row, col;\r\n\r\n        // Before drawing, clear existing canvas\r\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n        /* Loop through the number of rows and columns we've defined above\r\n         * and, using the rowImages array, draw the correct image for that\r\n         * portion of the \"grid\"\r\n         */\r\n        for (row = 0; row < numRows; row++) {\r\n            for (col = 0; col < numCols; col++) {\r\n                /* The drawImage function of the canvas' context element\r\n                 * requires 3 parameters: the image to draw, the x coordinate\r\n                 * to start drawing and the y coordinate to start drawing.\r\n                 * We're using our Resources helpers to refer to our images\r\n                 * so that we get the benefits of caching these images, since\r\n                 * we're using them over and over.\r\n                 */\r\n                ctx.drawImage(Resources.get(rowImages[row]), col * 101, row * 83);\r\n            }\r\n        }\r\n\r\n        // renderEntities();\r\n    }\r\n\r\n    /* This function is called by the render function and is called on each game\r\n     * tick. Its purpose is to then call the render functions you have defined\r\n     * on your enemy and player entities within app.js\r\n     */\r\n    function renderEntities() {\r\n        /* Loop through all of the objects within the allEnemies array and call\r\n         * the render function you have defined.\r\n         */\r\n        allEnemies.forEach(function(enemy) {\r\n            enemy.render();\r\n        });\r\n\r\n        player.render();\r\n    }\r\n\r\n    /* This function does nothing but it could have been a good place to\r\n     * handle game reset states - maybe a new game menu or a game over screen\r\n     * those sorts of things. It's only called once by the init() method.\r\n     */\r\n    function reset() {\r\n        // noop\r\n    }\r\n\r\n    /* Go ahead and load all of the images we know we're going to need to\r\n     * draw our game level. Then set init as the callback method, so that when\r\n     * all of these images are properly loaded our game will start.\r\n     */\r\n    Resources.load([\r\n        // Map sources\r\n        'images/stone-block.png',\r\n        'images/water-block.png',\r\n        'images/grass-block.png',\r\n        // Enemy source\r\n        'images/enemy-bug.png',\r\n        // Bonuses sources\r\n        'images/Gem_Blue.png',\r\n        'images/Gem_Green.png',\r\n        'images/Gem_Orange.png',\r\n        // Player sources\r\n        'images/char-boy.png',\r\n        'images/char-cat-girl.png',\r\n        'images/char-horn-girl.png',\r\n        'images/char-pink-girl.png',\r\n        'images/char-princess-girl.png'\r\n    ]);\r\n    // Resources.onReady(init);\r\n    Resources.onReady(modalActions.addPlayersToModalStart);\r\n\r\n    /* Assign the canvas' context object to the global variable (the window\r\n     * object when run in a browser) so that developers can use it more easily\r\n     * from within their app.js files.\r\n     */\r\n    global.ctx = ctx;\r\n\r\n    startPlayButton.addEventListener('click', function(e) {\r\n        modalActions.closeModalStart();\r\n        init();\r\n    });\r\n})(this);;/* Resources.js\r\n * This is simply an image loading utility. It eases the process of loading\r\n * image files so that they can be used within your game. It also includes\r\n * a simple \"caching\" layer so it will reuse cached images if you attempt\r\n * to load the same image multiple times.\r\n */\r\nvar Resources = (function() {\r\n    var resourceCache = {};\r\n    var readyCallbacks = [];\r\n\r\n    /* This is the publicly accessible image loading function. It accepts\r\n     * an array of strings pointing to image files or a string for a single\r\n     * image. It will then call our private image loading function accordingly.\r\n     */\r\n    function load(urlOrArr) {\r\n        if(urlOrArr instanceof Array) {\r\n            /* If the developer passed in an array of images\r\n             * loop through each value and call our image\r\n             * loader on that image file\r\n             */\r\n            urlOrArr.forEach(function(url) {\r\n                _load(url);\r\n            });\r\n        } else {\r\n            /* The developer did not pass an array to this function,\r\n             * assume the value is a string and call our image loader\r\n             * directly.\r\n             */\r\n            _load(urlOrArr);\r\n        }\r\n    }\r\n\r\n    /* This is our private image loader function, it is\r\n     * called by the public image loader function.\r\n     */\r\n    function _load(url) {\r\n        if(resourceCache[url]) {\r\n            /* If this URL has been previously loaded it will exist within\r\n             * our resourceCache array. Just return that image rather than\r\n             * re-loading the image.\r\n             */\r\n            return resourceCache[url];\r\n        } else {\r\n            /* This URL has not been previously loaded and is not present\r\n             * within our cache; we'll need to load this image.\r\n             */\r\n            var img = new Image();\r\n            img.onload = function() {\r\n                /* Once our image has properly loaded, add it to our cache\r\n                 * so that we can simply return this image if the developer\r\n                 * attempts to load this file in the future.\r\n                 */\r\n                resourceCache[url] = img;\r\n\r\n                /* Once the image is actually loaded and properly cached,\r\n                 * call all of the onReady() callbacks we have defined.\r\n                 */\r\n                if(isReady()) {\r\n                    readyCallbacks.forEach(function(func) { \r\n                        func.call(); \r\n                    });\r\n                }\r\n            };\r\n\r\n            /* Set the initial cache value to false, this will change when\r\n             * the image's onload event handler is called. Finally, point\r\n             * the image's src attribute to the passed in URL.\r\n             */\r\n            resourceCache[url] = false;\r\n            img.src = url;\r\n        }\r\n    }\r\n\r\n    /* This is used by developers to grab references to images they know\r\n     * have been previously loaded. If an image is cached, this functions\r\n     * the same as calling load() on that URL.\r\n     */\r\n    function get(url) {\r\n        return resourceCache[url];\r\n    }\r\n\r\n    /* This function determines if all of the images that have been requested\r\n     * for loading have in fact been properly loaded.\r\n     */\r\n    function isReady() {\r\n        var ready = true;\r\n        for(var k in resourceCache) {\r\n            if(resourceCache.hasOwnProperty(k) &&\r\n               !resourceCache[k]) {\r\n                ready = false;\r\n            }\r\n        }\r\n        return ready;\r\n    }\r\n\r\n    /* This function will add a function to the callback stack that is called\r\n     * when all requested images are properly loaded.\r\n     */\r\n    function onReady(func) {\r\n        readyCallbacks.push(func);\r\n    }\r\n\r\n    /* This object defines the publicly accessible functions available to\r\n     * developers by creating a global Resources object.\r\n     */\r\n    return {\r\n        load: load,\r\n        get: get,\r\n        onReady: onReady,\r\n        isReady: isReady\r\n    };\r\n})();\r\n\r\nmodule.exports = Resources;\r\n;module.exports = (function(global) {\r\n\r\n    const Resources = require('./resources.js'),\r\n          utils = require('./utils.js');\r\n\r\n    var allPlayers = [\r\n            // Player sources\r\n            'images/char-boy.png',\r\n            'images/char-cat-girl.png',\r\n            'images/char-horn-girl.png',\r\n            'images/char-pink-girl.png',\r\n            'images/char-princess-girl.png'\r\n        ],\r\n        allKeysForPlayers = [\r\n            'Boy',\r\n            'Cat',\r\n            'Horn',\r\n            'Pink',\r\n            'Princess'\r\n        ],\r\n        modalWindow = document.querySelectorAll('.modalStart')[0];\r\n\r\n    function addPlayersToModalStart() {\r\n        var modalPlayers = document.getElementById('modalPlayers'),\r\n            playerContainer, player, i, j, len, lenJ;\r\n\r\n        for (i = 0, len = allPlayers.length; i < len; i++) {\r\n            player = Resources.get(allPlayers[i]);\r\n            playerContainer = document.createElement('div');\r\n            playerContainerText = document.createElement('span');\r\n            playerContainer.className = 'playerContainer';\r\n\r\n            for (j = 0, lenJ = allKeysForPlayers.length; j < lenJ; j++) {\r\n                if (allPlayers[i].indexOf(allKeysForPlayers[j].toLowerCase()) > -1) {\r\n                    player.dataset.bodyType = allKeysForPlayers[j];\r\n                    playerContainerText.textContent = allKeysForPlayers[j];\r\n                    playerContainer.appendChild(player);\r\n                    playerContainer.appendChild(playerContainerText);\r\n                }\r\n            }\r\n\r\n            modalPlayers.appendChild(playerContainer);\r\n        }\r\n    }\r\n\r\n    function choosePlayer(e) {\r\n        player = e.target.dataset;\r\n\r\n        for (var i = playerBody.length - 1; i >= 0; i--) {\r\n            if (playerBody[i].type === player.playerbody) {\r\n                activePlayer.setPlayer(playerBody[i].url);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    function closeModalStart() {\r\n        utils.toggleClass(modalWindow, 'active');\r\n    }\r\n\r\n\r\n\r\n    // document.addEventListener('click', function(e) {\r\n    // });\r\n\r\n    return {\r\n        addPlayersToModalStart: addPlayersToModalStart,\r\n        closeModalStart: closeModalStart\r\n    };\r\n\r\n})(this);;module.exports = (function() {\r\n\r\n    /**\r\n     * @description Toggle given class using cross browser property ClassName.\r\n     * @param {Object} element DOMElement to toggle class.\r\n     * @param {String} className Class name that should be toggled.\r\n     */\r\n    // toggleClass function from https://stackoverflow.com/questions/18880890/how-do-i-toggle-an-elements-class-in-pure-javascript\r\n    function toggleClass(element, className) {\r\n        if (!element || !className) {\r\n            return;\r\n        }\r\n\r\n        var classString = element.className,\r\n            nameIndex = classString.indexOf(className);\r\n        if (nameIndex == -1) {\r\n            classString += ' ' + className;\r\n        } else {\r\n            classString = classString.substr(0, nameIndex) + classString.substr(nameIndex + className.length);\r\n        }\r\n        element.className = classString;\r\n    }\r\n\r\n    return {\r\n        toggleClass: toggleClass\r\n    };\r\n})(this);"]}